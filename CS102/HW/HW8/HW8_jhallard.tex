
% Programming/Coding Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
% This template uses a Perl script as an example snippet of code, most other
% languages are also usable. Configure them in the "CODE INCLUSION 
% CONFIGURATION" section.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%   PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{multicol}
\usepackage{fullpage,amsthm,amsfonts,amssymb,epsfig,amsmath}
\usepackage{tikz}
\usepackage{verbatim,array}
\usepackage[active,tightpage]{preview}
\usetikzlibrary{decorations.pathmorphing,shapes,positioning,calc,fit,arrows,arrows.meta}
\setlength\PreviewBorder{5pt}

\usepackage{scrextend}
\newcommand{\tikzmark}[1]{%
  \tikz[overlay,remember picture] \node(#1){};
}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle} % Top center head
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule
\newcommand{\tab}{\hspace*{3em}}

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%   CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------

\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
\lstloadlanguages{Perl} % Load Perl syntax for listings, for a list of other languages supported see: ftp://ftp.tex.ac.uk/tex-archive/macros/latex/contrib/listings/listings.pdf
\lstset{language=Perl, % Use Perl in this example
        frame=single, % Single frame around code
        basicstyle=\small\ttfamily, % Use small true type font
        keywordstyle=[1]\color{Blue}\bf, % Perl functions bold and blue
        keywordstyle=[2]\color{Purple}, % Perl function arguments purple
        keywordstyle=[3]\color{Blue}\underbar, % Custom functions underlined and blue
        identifierstyle=, % Nothing special about identifiers                                         
        commentstyle=\usefont{T1}{pcr}{m}{sl}\color{MyDarkGreen}\small, % Comments small dark green courier font
        stringstyle=\color{Purple}, % Strings are purple
        showstringspaces=false, % Don't put marks in string spaces
        tabsize=5, % 5 spaces per tab
        %
        % Put standard Perl functions not included in the default language here
        morekeywords={rand},
        %
        % Put Perl function parameters here
        morekeywords=[2]{on, off, interp},
        %
        % Put user defined functions here
        morekeywords=[3]{test},
        %
        morecomment=[l][\color{Blue}]{...}, % Line continuation (...) like blue comment
        numbers=left, % Line numbers on left
        firstnumber=1, % Line numbers start with line 1
        numberstyle=\tiny\color{Blue}, % Line numbers are blue and small
        stepnumber=5 % Line numbers go in steps of 5
}

% Creates a new command to include a perl script, the first parameter is the filename of the script (without .pl), the second parameter is the caption
\newcommand{\perlscript}[2]{
\begin{itemize}
\item[]\lstinputlisting[caption=#2,label=#1]{#1.pl}
\end{itemize}
}

%----------------------------------------------------------------------------------------
%   DOCUMENT STRUCTURE COMMANDS
%   Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
\stepcounter{homeworkProblemCounter} % Increase counter for number of problems
\renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the name of the problem
\section{\homeworkProblemName} % Make a section in the document with the custom problem count
\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
\exitProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}} % Makes the box around the problem answer and puts the content inside
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
\renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the name of the section from the environment argument
\subsection{\homeworkSectionName} % Make a subsection with the custom name of the subsection
\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
\enterProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

%----------------------------------------------------------------------------------------
%   NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Homework\ \#8} % Assignment title
\newcommand{\hmwkDueDate}{Tuesday,\ June 2nd,\ 2015} % Due date
\newcommand{\hmwkClass}{CMPS\ 102} % Course/class
\newcommand{\hmwkClassTime}{4:00pm} % Class/lecture time
\newcommand{\hmwkClassInstructor}{Warmuth} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{John Allard \ 1437547
} % Your name


%----------------------------------------------------------------------------------------
%----------------------------------------------------------------------------------------
%   USER SETTINGS
%----------------------------------------------------------------------------------------
%----------------------------------------------------------------------------------------
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}



%----------------------------------------------------------------------------------------
%   TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\vspace{2in}
\textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
\normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
\vspace{0.1in}\large{\textit{}}
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%   TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

% \tableofcontents
\newpage





%----------------------------------------------------------------------------------------
%   PROBLEM 1
%----------------------------------------------------------------------------------------

% To have just one problem per page, simply put a \clearpage after each problem

\begin{homeworkProblem}

In the slides an algorithm was given for the following problem: Given a digraph $G$ and a source node $s$ and sink node $t$, find the maximum number of edge disjoint paths from $s$ to $t$.\\
Give an algorithm that finds the maximum number of edge disjoint SIMPLE paths from $s$ to $t$ (i.e. paths with no loops). Hint: Start with the maximum number of disjoint paths from $s$ to $t$ and then delete loops. \\

\textbf{Algorithm : } This algorithm piggy-backs on the basic algorithm that is used to find the number of edge disjoint paths. It then takes the flow network that is output by the original algorithm, goes over all of the paths and uses an array and a stack to find and remove the cycles from the paths.  \\

\begin{lstlisting}
# Input : Set of paths P = {p1, p2, .., pn } returned
# from standard FF algorithm. p = {s, v, v, .. t} is a list of vertices
# that start at s, end at t, and visits internal vertices along the way
# Output : Set of paths P' = {p1', p2', .., pn'} that have no cycles

find_simple(P)
  while P not empty :
    s = empty stack
    a = empty map
    p = P.extract_path() # grab next path from P
    Q = empty set of paths

    for vertex v in p :
      if a.contains(v) : # if our map says we've seen this vertex
        do : # pop vertices off the stack
          q = s.pop()
        while q != v # until we have removed the loop
      else : # if we haven't seen this vertex yet
        a.insert(v) # insert the vertex into our map
        s.push(v) # push the vertex onto the stack
    q = empty list
    while s.size() : # while vertices in our stack
      q.insert(s.pop()) # put them in the new simple path
    Q.insert(q.reverse()) # put the new path in our set of simple paths
    # note a and s are emptied for the next iteration
  return Q



  
\end{lstlisting}

a) Reason that the solution produces the correct maximum number of edge disjoint simple paths. \\
\textbf{Answer : } In any flow network, the number maximum number of edge-disjoint paths is equal to the number of simple edge disjoint paths, this is because any non-simple edge disoint path can be made simple by removing any loops, and since we are just removing edges from the non-simple path, this process cannot turn an edge-disjoint path into one that is not edge-disjoint, we would have to add edges to the path to do such a thing. Since I am returning the same number of edge-disjoint paths that are given to my algorithm from the Ford-Fulkenson routine, I am returning the correct number of paths. Now I need to reason that the paths I return truly are simple. \\
To see this, we turn to the algorithm. I take a given not-necessarily simple e.d. path, and walk along all of its vertices. During each walk along the vertices, I use a stack and a standard map that takes a vertex as an argument and tells of if it has already been entered into the map. I also use a stack that has the vertices encountered pushed onto it in the order they are seen, this keeps the most recently seen vertices at the top of the stack. The map is key for finding the cycles, if we come across a vertex that is already in the map, this means we have already seen it on our path and thus we have hit a cycle. If this is the case, we continually pop vertices off the top of the stack until we get to the vertex we have already seen. This removes the cycle from the path, at which point we continue processing the vertices. 

b) What is the running time of your algorithm? \\

\textbf{Answer : } My algorithm first needs to use the standard algorithm for finding edge-disjoint paths, which when using the Edmonds-Karp algorithm runs in time $O(VE^2)$. Once this is finished, my algorithm then proceeds. \\
My algorithm consists of one main outer loop that iterates for as many times as there are paths in the graph, lets call this number $k$. Inside of this outer loop, we have an innter for-loop that has to iterate as many times as there are edges in the given path, which can be upper-bounded by $E$, the total number of edges in the graph.  Inserting and removing from both the stack and map can be done in constant time. Thus, composing the inner and outer-loops, my algorithm runs in time $O(kE)$. This is asymptotically less than the running time of the Ford-Fulkerson algorithm, so the total running time of the algorithms run together is still $O(VE^2)$.
\end{homeworkProblem}



%----------------------------------------------------------------------------------------
%   PROBLEM 2
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
In class we give a flow argument for showing that every $k$-regular bipartite graph has a perfect matching. In such graphs every women knows $k$ men and every man knows $k$ women. \\
Give an alternate proof using Hall's Theorem: That is show that for $k$-regular graphs the following holds: For every subset $S$ of the women, $|N(S)| >= |S|$,  where $N(S)$ is the total set of men they know together.

\end{homeworkProblem}



\newpage

%----------------------------------------------------------------------------------------
%   PROBLEM 3
%----------------------------------------------------------------------------------------
\begin{homeworkProblem}

KT 12, p420. \\
Give a reason why your algorithm reduces the flow as much as possible. \\

Hint: Use Ford-Fulkerson to find a min cut. Somehow reduce the min cut.
\end{homeworkProblem}


\newpage


%----------------------------------------------------------------------------------------
%   PROBLEM 4
%----------------------------------------------------------------------------------------
\begin{homeworkProblem}

KT 21, p427. \\ This uses bipartite matching.


\end{homeworkProblem}
\newpage






% %----------------------------------------------------------------------------------------
% %   PROBLEM 5
% %----------------------------------------------------------------------------------------
\begin{homeworkProblem}


\vspace{2mm}
5) KT 27, p431.
Design a flow network where each driver $p_j$ get flow $Delta_j$. \\ Then round up the capacities and use the integral flow theorem.
\vspace{6mm}


\end{homeworkProblem}

\newpage





% %----------------------------------------------------------------------------------------
% %   PROBLEM 6
% %----------------------------------------------------------------------------------------
\begin{homeworkProblem}


\vspace{2mm}
KT 45, p444.
Think circulation!
\end{homeworkProblem}

\newpage


%----------------------------------------------------------------------------------------

\end{document}