
% Programming/Coding Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
% This template uses a Perl script as an example snippet of code, most other
% languages are also usable. Configure them in the "CODE INCLUSION 
% CONFIGURATION" section.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%   PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{multicol}
\usepackage{fullpage,amsthm,amsfonts,amssymb,epsfig,amsmath}
\usepackage{tikz}
\usepackage{verbatim,array}
\usepackage[active,tightpage]{preview}
\usetikzlibrary{decorations.pathmorphing,shapes,positioning,calc,fit,arrows,arrows.meta}
\setlength\PreviewBorder{5pt}

\usepackage{scrextend}
\newcommand{\tikzmark}[1]{%
  \tikz[overlay,remember picture] \node(#1){};
}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle} % Top center head
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule
\newcommand{\tab}{\hspace*{3em}}

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%   CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------

\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
\lstloadlanguages{Perl} % Load Perl syntax for listings, for a list of other languages supported see: ftp://ftp.tex.ac.uk/tex-archive/macros/latex/contrib/listings/listings.pdf
\lstset{language=Perl, % Use Perl in this example
        frame=single, % Single frame around code
        basicstyle=\small\ttfamily, % Use small true type font
        keywordstyle=[1]\color{Blue}\bf, % Perl functions bold and blue
        keywordstyle=[2]\color{Purple}, % Perl function arguments purple
        keywordstyle=[3]\color{Blue}\underbar, % Custom functions underlined and blue
        identifierstyle=, % Nothing special about identifiers                                         
        commentstyle=\usefont{T1}{pcr}{m}{sl}\color{MyDarkGreen}\small, % Comments small dark green courier font
        stringstyle=\color{Purple}, % Strings are purple
        showstringspaces=false, % Don't put marks in string spaces
        tabsize=5, % 5 spaces per tab
        %
        % Put standard Perl functions not included in the default language here
        morekeywords={rand},
        %
        % Put Perl function parameters here
        morekeywords=[2]{on, off, interp},
        %
        % Put user defined functions here
        morekeywords=[3]{test},
        %
        morecomment=[l][\color{Blue}]{...}, % Line continuation (...) like blue comment
        numbers=left, % Line numbers on left
        firstnumber=1, % Line numbers start with line 1
        numberstyle=\tiny\color{Blue}, % Line numbers are blue and small
        stepnumber=5 % Line numbers go in steps of 5
}

% Creates a new command to include a perl script, the first parameter is the filename of the script (without .pl), the second parameter is the caption
\newcommand{\perlscript}[2]{
\begin{itemize}
\item[]\lstinputlisting[caption=#2,label=#1]{#1.pl}
\end{itemize}
}

%----------------------------------------------------------------------------------------
%   DOCUMENT STRUCTURE COMMANDS
%   Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
\stepcounter{homeworkProblemCounter} % Increase counter for number of problems
\renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the name of the problem
\section{\homeworkProblemName} % Make a section in the document with the custom problem count
\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
\exitProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}} % Makes the box around the problem answer and puts the content inside
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
\renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the name of the section from the environment argument
\subsection{\homeworkSectionName} % Make a subsection with the custom name of the subsection
\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
\enterProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

%----------------------------------------------------------------------------------------
%   NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Homework\ \#8} % Assignment title
\newcommand{\hmwkDueDate}{Tuesday,\ June 2nd,\ 2015} % Due date
\newcommand{\hmwkClass}{CMPS\ 102} % Course/class
\newcommand{\hmwkClassTime}{4:00pm} % Class/lecture time
\newcommand{\hmwkClassInstructor}{Warmuth} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{John Allard \ 1437547
} % Your name


%----------------------------------------------------------------------------------------
%----------------------------------------------------------------------------------------
%   USER SETTINGS
%----------------------------------------------------------------------------------------
%----------------------------------------------------------------------------------------
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}



%----------------------------------------------------------------------------------------
%   TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\vspace{2in}
\textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
\normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
\vspace{0.1in}\large{\textit{}}
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%   TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

% \tableofcontents
\newpage





%----------------------------------------------------------------------------------------
%   PROBLEM 1
%----------------------------------------------------------------------------------------

% To have just one problem per page, simply put a \clearpage after each problem

\begin{homeworkProblem}

In the slides an algorithm was given for the following problem: Given a digraph $G$ and a source node $s$ and sink node $t$, find the maximum number of edge disjoint paths from $s$ to $t$.\\
Give an algorithm that finds the maximum number of edge disjoint SIMPLE paths from $s$ to $t$ (i.e. paths with no loops). Hint: Start with the maximum number of disjoint paths from $s$ to $t$ and then delete loops. \\

\textbf{Algorithm : } This algorithm piggy-backs on the basic algorithm that is used to find the number of edge disjoint paths. It then takes the flow network that is output by the original algorithm, goes over all of the paths and uses an array and a stack to find and remove the cycles from the paths.  \\

\begin{lstlisting}
# Input : Set of paths P = {p1, p2, .., pn } returned
# from standard FF algorithm. p = {s, v, v, .. t} is a list of vertices
# that start at s, end at t, and visits internal vertices along the way
# Output : Set of paths P' = {p1', p2', .., pn'} that have no cycles

find_simple(P)
  while P not empty :
    s = empty stack
    a = empty map
    p = P.extract_path() # grab next path from P
    Q = empty set of paths

    for vertex v in p :
      if a.contains(v) : # if our map says we've seen this vertex
        do : # pop vertices off the stack
          q = s.pop()
        while q != v # until we have removed the loop
      else : # if we haven't seen this vertex yet
        a.insert(v) # insert the vertex into our map
        s.push(v) # push the vertex onto the stack
    q = empty list
    while s.size() : # while vertices in our stack
      q.insert(s.pop()) # put them in the new simple path
    Q.insert(q.reverse()) # put the new path in our set of simple paths
    # note a and s are emptied for the next iteration
  return Q
\end{lstlisting}

a) Reason that the solution produces the correct maximum number of edge disjoint simple paths. \\
\textbf{Answer : } In any flow network, the number maximum number of edge-disjoint paths is equal to the number of simple edge disjoint paths, 
his is because any non-simple edge disoint path can be made simple by removing any loops, and since we are just removing edges from the non-simple path, this process cannot turn an edge-disjoint path into one that is not edge-disjoint, we would
have to add edges to the path to do such a thing. Since I am returning the same number of edge-disjoint paths that are given to my algorithm from the Ford-Fulkenson routine, I am returning the correct number of paths. Now I need to reason
that the paths I return truly are simple. \\
To see this, we turn to the algorithm. I take a given not-necessarily simple e.d. path, and walk along all of its vertices. During each walk along
the vertices, I use a stack and a standard map that takes a vertex as an argument and tells of if it has already been entered into the map. I also use a stack that has the vertices encountered pushed onto it in the order they are seen, this
keeps the most recently seen vertices at the top of the stack. The map is key for finding the cycles, if we come across a vertex that is already in the map, this means we have already seen it on our path and thus we have hit a cycle. If this is
the case, we continually pop vertices off the top of the stack until we get to the vertex we have already seen. This removes the cycle from the path, at which point we continue processing the vertices. \\

b) What is the running time of your algorithm? \\

\textbf{Answer : } My algorithm first needs to use the standard algorithm for finding edge-disjoint paths, which when using the Edmonds-Karp 
lgorithm runs in time $O(VE^2)$. Once this is finished, my algorithm then proceeds. \\
My algorithm consists of one main outer loop that iterates for as many times as there are paths in the graph, lets call this number $k$. Inside
of this outer loop, we have an innter for-loop that has to iterate as many times as there are edges in the given path, which can be upper-bounded by $E$, the total number of edges in the graph.  Inserting and removing from both the stack and map
can be done in constant time. Thus, composing the inner and outer-loops, my algorithm runs in time $O(kE)$. This is asymptotically less than the running time of the Ford-Fulkerson algorithm, so the total running time of the algorithms run together
is still $O(VE^2)$.
\end{homeworkProblem}



%----------------------------------------------------------------------------------------
%   PROBLEM 2
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
In class we give a flow argument for showing that every $k$-regular bipartite graph has a perfect matching. In such graphs every women knows $k$ men
and every man knows $k$ women. \\
Give an alternate proof using Hall's Theorem: That is show that for $k$-regular graphs the following holds: For every subset $S$ of the women,
$|N(S)| >= |S|$,  where $N(S)$ is the total set of men they know together. \\[.15in]

\textbf{Answer : } We are given $k$-regular bipartite graph with vertex set $V = L \cup R$ (left and right vertices, women on the left and men on
the right) and edge set $E$. Note that $|L| = |R|$ necessarily otherwise no perfect matching could exist. I need to show that Hall's theorem holds, 
aka that for every subset of vertices $S$ in either $L$ or $R$, if $|N(S)| \geq |S|$. If I show that this is true, then Hall's theorem says there must exist a perfect matching. \\

To start, choose an arbitrary subset of women $S \subseteq L$. Let $E$ be the number of edges that leave this group,  and let $N(S)$ be the vertices
in $R$ that are connected to $S$ via these edges. Because we are given a $k$-regular graph, each vertex $v \in V$ has $k \geq 1$ edges incident to it, 
and no parallel edges are allowed, so each edge leaving a specific vertex $v$ must end at a  unique vertex (no two edges start and end at the same vertex).
There are also no self-loop allowed. Thus $|E| \leq k \times |N(S)|$. Also note that $|S| = \frac{|E|}{k}$, because $E$ exactly consists of $k$ edges for
 each of the vertices in $S$. Thus, if we divide both sides of the before-given inequality by $k$, we get :
$$|E|/k \leq |N(S)|$$
$$|S| \leq |N(S)|$$ 
The last line is what we wished to show, completing the proof.

\end{homeworkProblem}



\newpage

%----------------------------------------------------------------------------------------
%   PROBLEM 3
%----------------------------------------------------------------------------------------
\begin{homeworkProblem}

Consider the following problem. You are given a flow network with unit-
capacity edges: It consists of a directed graph $G = (V , E)$, a source $s \in V$,
and a sink $t \in V$; and $ce = 1$ for every $e \in E$. You are also given a parameter $k$.
The goal is to delete $k$ edges so as to reduce the maximum $s-t$ flow in
$G$ by as much as possible. In other words, you should find a set of edges
$F \subseteq E$ so that $|F| = k$ and the maximum $s-t$ flow in $G' = (V , E − F)$ is as small
as possible subject to this.
Give a polynomial-time algorithm to solve this problem.


(Give a reason why your algorithm reduces the flow as much as possible. Hint: Use Ford-Fulkerson 
to find a min cut. Somehow reduce the min cut.)

\textbf{Answer :}My algorithm will piggy-back on the typical Ford-Fulkerson algorithm. It will start by running the FF method, then looking at the final residual graph. With this graph, we find all vertices which are reachable from the source vertex $s$ using BFS. We find these vertices because any edges that travels from one of these vertices to a vertex not reachable from $s$ is an  edge that will be included in the minimum cut. At this point, we remove $k$ of these edges, which because this is a min-cut (which is equal to the max-flow), will reduce the max-flow by a value of $k$. This is true becauase the min-cut is a bottle-neck, there are no other means of directing current around these edges to get to the sink from the source, so every edge that is removed here will reduce the flow by the $1$, since each edge in this cut has a flow of one. \\

\textbf{Algorithm : } \\

Note, I am assuming I don't have to write out the BFS algorithm or the FF algorithm as we have already
had to implement those for previous assignments or previous classes in the case of BFS
\begin{lstlisting}

# input : Flow network G with vertices G.V and edges G.E
# k, the number of edges to remove
# Output : Flow network G' such that the max-flow has been reduced as much as possible
shrink_flow(G, k) :
residual_graph = Ford_Fulkerson(G) # run FF and retreive the final residual graph
V_p = BFS(residual_graph, G.s) # V_p is a list of vertices reachable from the source
                               # vertex in the residual graph
E_p = empty list # this will hold the min-cut edges
for v in V_p : # cycle through all reachable vertices
  for e in v.edges # cycle through all incident edges to the current vertex
    if e.target not in V_p : # if the edge touches a vertex not reachable from source vertex s
      E_p.insert(e)

while k >= 0 : # while we haven't removed k edges
  E_p.remove_front() # remove edge from min-cut edges

G_p = Graph(V, E_p) # new graph with same vertices but k edges removed from min-cut
return G_p
\end{lstlisting}

In a flow-network, the minimum-cut is equal to the maximum-flow. This means that every edge in the min-cut must be completely saturated with flow, and since each edge has a capacity of $1$, each flow on the edges in the min-cut must be 1. This means that by removing $k$ edges from the min-cut, we will necessarily have removed $k$ units of flow from the graph. Because we are only allowed to remove $k$ edges, and each edge has at most $1$ unit of flow going through it, this is the optimal solution, there is no way to remove more than $k$ units of flow. My algorithm uses the FF method, which can run in time $O(VE^2)$, it then uses BFS, which runs in time $O(V+E)$. It then runs a double for-loop, with the outer loop iterating over all reachable vertices from $s$, and the inner loop iterating over all edges that eminate from those vertices. Because a residual graph returned from FF must not contain an $s-t$ path (this is a termination condition for FF), the number of reachable vertices from $s$ is bounded above by $V-1$. The number of edges incident to these $V-1$ vertices is at most $E-1$, since we aren't able to reach vertex $t$ and there must exist at least one edge incident to vertex $t$. The inside of the inner-loop simply does a comparison and an insert into a list, which is constant time. Thus, by composing the two loops, the rest of my algorithm runs in time $O(|(V-1)||(E-1))$ = $O(VE)$. Combining the FF method, BFS, and the rest of my algorithm gives a running time of $O(VE^2) + O(V+E) + O(VE) = O(VE^2)$, which is indeed polynomial in the number of vertices and edges. \\
\end{homeworkProblem}


% \newpage


%----------------------------------------------------------------------------------------
%   PROBLEM 4
%----------------------------------------------------------------------------------------
\begin{homeworkProblem}

 You’re helping to organize a class on campus that has decided to give all
its students wireless laptops for the semester. Thus there is a collection
of n wireless laptops; there is also have a collection of $n$ wireless access
points, to which a laptop can connect when it is in range.
The laptops are currently scattered across campus; laptop $l$ is within
range of a set $S_l$ of access points. We will assume that each laptop is within
range of at least one access point (so the sets $S_l$ are nonempty); we will
also assume that every access point p has at least one laptop within range
of it.
To make sure that all the wireless connectivity software is working
correctly, you need to try having laptops make contact with access points
in such a way that each laptop and each access point is involved in at
least one connection. Thus we will say that a test set $T$ is a collection of
ordered pairs of the form $(l, p)$, for a laptop $l$ and access point $p$, with
the properties that

\begin{enumerate}
\item if $(l, p) \in T$, then $l$ is within range of $p$
\item Each laptop appears in at least one ordered-pair in $T$.
\item Each access point appears in at least one pair in $T$
\end{enumerate}

This way, by trying out all the connections specified by the pairs in $T$,
we can be sure that each laptop and each access point have correctly
functioning software.
The problem is: Given the sets $S_l$ for each laptop (i.e., which laptops
are within range of which access points), and a number $k$, decide whether
there is a test set of size at most $k$.

a.)  Give an example of an instance of this problem for which there is no
test set of size n. (Recall that we assume each laptop is within range
of at least one access point, and each access point p has at least one
laptop within range of it.) \\
Take $n = 3$, with the following properties :
Laptop 1 is in range of access points 2 and 3. Laptop 2 is only in range of access point
1, and laptop 3 is only in range of access point 1. All access points have a close laptop,
and all laptops are within range of an access point. However, since laptops 2 and 3 can only 
access point 1, the two pairs $(2, 1)$ and $(3, 1)$ must be in the test set. However, since each
access point must also be tested, this means that the sets $(1, 2)$ and $(1, 3)$ must be included. This
however leads to a test-set of size 4 while our number of laptops and access points ($n$) is 3.

b.)  Give a polynomial-time algorithm that takes the input to an instance
of this problem (including the parameter k) and decides whether
there is a test set of size at most k. \\

we have to turn this into a circulation problem (thanks for the hint). We start by labeleing all of the laptops
as having supplies equal to the number of access points that are in range of the laptop. The 
\end{homeworkProblem}
\newpage






% %----------------------------------------------------------------------------------------
% %   PROBLEM 5
% %----------------------------------------------------------------------------------------
\begin{homeworkProblem}


\vspace{2mm}
5) KT 27, p431.
Design a flow network where each driver $p_j$ get flow $Delta_j$. \\ Then round up the capacities and use the integral flow theorem.
\vspace{6mm}


\end{homeworkProblem}

\newpage





% %----------------------------------------------------------------------------------------
% %   PROBLEM 6
% %----------------------------------------------------------------------------------------
\begin{homeworkProblem}


\vspace{2mm}
KT 45, p444.
Think circulation!
\end{homeworkProblem}

\newpage


%----------------------------------------------------------------------------------------

\end{document}