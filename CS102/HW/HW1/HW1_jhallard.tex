%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Programming/Coding Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
% This template uses a Perl script as an example snippet of code, most other
% languages are also usable. Configure them in the "CODE INCLUSION 
% CONFIGURATION" section.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%   PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle} % Top center head
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule
\newcommand{\tab}{\hspace*{3em}}

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%   CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------

\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
\lstloadlanguages{Perl} % Load Perl syntax for listings, for a list of other languages supported see: ftp://ftp.tex.ac.uk/tex-archive/macros/latex/contrib/listings/listings.pdf
\lstset{language=Perl, % Use Perl in this example
        frame=single, % Single frame around code
        basicstyle=\small\ttfamily, % Use small true type font
        keywordstyle=[1]\color{Blue}\bf, % Perl functions bold and blue
        keywordstyle=[2]\color{Purple}, % Perl function arguments purple
        keywordstyle=[3]\color{Blue}\underbar, % Custom functions underlined and blue
        identifierstyle=, % Nothing special about identifiers                                         
        commentstyle=\usefont{T1}{pcr}{m}{sl}\color{MyDarkGreen}\small, % Comments small dark green courier font
        stringstyle=\color{Purple}, % Strings are purple
        showstringspaces=false, % Don't put marks in string spaces
        tabsize=5, % 5 spaces per tab
        %
        % Put standard Perl functions not included in the default language here
        morekeywords={rand},
        %
        % Put Perl function parameters here
        morekeywords=[2]{on, off, interp},
        %
        % Put user defined functions here
        morekeywords=[3]{test},
        %
        morecomment=[l][\color{Blue}]{...}, % Line continuation (...) like blue comment
        numbers=left, % Line numbers on left
        firstnumber=1, % Line numbers start with line 1
        numberstyle=\tiny\color{Blue}, % Line numbers are blue and small
        stepnumber=5 % Line numbers go in steps of 5
}

% Creates a new command to include a perl script, the first parameter is the filename of the script (without .pl), the second parameter is the caption
\newcommand{\perlscript}[2]{
\begin{itemize}
\item[]\lstinputlisting[caption=#2,label=#1]{#1.pl}
\end{itemize}
}

%----------------------------------------------------------------------------------------
%   DOCUMENT STRUCTURE COMMANDS
%   Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
\stepcounter{homeworkProblemCounter} % Increase counter for number of problems
\renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the name of the problem
\section{\homeworkProblemName} % Make a section in the document with the custom problem count
\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
\exitProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}} % Makes the box around the problem answer and puts the content inside
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
\renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the name of the section from the environment argument
\subsection{\homeworkSectionName} % Make a subsection with the custom name of the subsection
\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
\enterProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

%----------------------------------------------------------------------------------------
%   NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Homework\ \#1} % Assignment title
\newcommand{\hmwkDueDate}{Tuesday,\ April\ 7,\ 2015} % Due date
\newcommand{\hmwkClass}{CMPS\ 102} % Course/class
\newcommand{\hmwkClassTime}{4:00pm} % Class/lecture time
\newcommand{\hmwkClassInstructor}{Warmuth} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{John Allard \ 1437547
} % Your name


%----------------------------------------------------------------------------------------
%----------------------------------------------------------------------------------------
%   USER SETTINGS
%----------------------------------------------------------------------------------------
%----------------------------------------------------------------------------------------
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}



%----------------------------------------------------------------------------------------
%   TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\vspace{2in}
\textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
\normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
\vspace{0.1in}\large{\textit{}}
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%   TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

\newpage
% \tableofcontents
% \newpage

%----------------------------------------------------------------------------------------
%   PROBLEM 1
%----------------------------------------------------------------------------------------

% To have just one problem per page, simply put a \clearpage after each problem

\begin{homeworkProblem}
In a binary tree all nodes are either internal or they are leaves. In our definition, internal
nodes always have two children and leaves have zero children. Prove that for such trees, the
number of leaves is always one more than the number of internal nodes.
There are many possible proofs based on induction, but there might be others. \\

\textbf{Answer : } \\[.2in]

Let $T$ be a binary tree subject to the definition above, $T_I$ be the number of internal nodes, and $T_L$ the number of leaves in $T$.
Let $P(n)$ be the statement `Given a binary tree $T$ on $n$ internal nodes, $T_L = T_I + 1 = n + 1$'.

\textbf{Base Case} \\
$P(n=0)$ : A tree with no internal nodes consists of only a root node, which would be a leaf. Thus 
$$T_L = 1, T_I = 0, T_L = T_I + 1 $$
Thus the base case is confirmed. \\

\textbf{Inductive Case} \\
Assume for any binary tree $T$ on $ n \geq 1$ internal nodes that $P(n)$ is true, i.e. $T_L = T_I + 1 = n + 1$. Now, pick an arbitrary binary tree on $n+1$ internal nodes, call it $T$. Note that because $T_I = n+1 \geq 1$, at least one internal node with 2 leaves as children must exist. Select any of these internal nodes, label that node $k$. Take a new leaf node, and put it in place of the internal node $k$. This exchange has two effects, it reduces the number of internal nodes by one (removal of $k$), and reduces the number of leaves by one (remove the two leaf-children of $k$, place a new leaf in place of $k$, $-2+1 = -1$). Label this new tree $T'$. \\
$$T_I' = T_I - 1$$
Because $T$ was a binary tree on $n+1$ internal nodes :
$$ T_I = n + 1$$
$$ T_I' = (n + 1) - 1 $$
$$ T_I' = n $$
Since $T'$ is on $n$ internal nodes, we can apply our inductive hypothesis, $T_L = T_I+1$ 
$$ T_L' = T_I'+1 $$
$$ T_L' = (n)+1 $$
To get from $T$ to $T'$, we removed one leaf node in the process. Thus :
$$ T_L = T_L' + 1 $$
$$ T_L = (n+1)+1 = n+2 $$
$$ T_L = n+2 = (n+1)+1 = (T_I)+1 $$
Which is exactly $P(n+1)$. 

\end{homeworkProblem}

\newpage

%----------------------------------------------------------------------------------------
%   PROBLEM 2
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}

For $n \geq 0$ consider $2^n \times 2^n$ matrices of 1s and 0s in which all elements are 1, except one which
is 0 (The 0 is at an arbitrary position).  \\
Operation: At each step, we can replace three 1s forming an ”L” with three 0s (The L’s can
have an arbitrary orientation). \\ 
Prove that for such matrices there always is a sequence of operations that transforms the
matrix to the all 0 matrix. \\

\textbf{Answer : } \\[.2in]

Let $M_n$ designate the $2^n \times 2^n$ matrix of all ones except a single zero as described above for $n \geq 0$. \\
Let $P(n)$ be the statement `Given a matrix $M_n$ for $n \geq 0$, $M_n$ can be reduced to the all-zero matrix by a sequence of L-removal operations which changes 3 ones to zeros in an L pattern of arbitray orientation'. \\
\textbf{Base Case} \\
$P(n=0)$ : If $n=0$, then $M_n$ is a $2^0 \times 2^0 = 1 \times 1$ matrix. Because all matrices of the above form must have a single 0, and a $1 \times 1$ matrix has only one component, the entire matrix is zero and thus we need no operations to reduce it to the zero matrix. Thus the base case is confirmed.

\textbf{Inductive Case} \\
Assume for any given $n \geq 1$ that $P(n)$ holds, i.e. that the matrix $M_n$ can be reduced to the zero matrix via a sequence of L-removal operations. Construct a matrix of the form $M_{n+1}$ (all ones except a single zero placed anywhere). $M_{n+1}$ must be square and have sides that are a power of two, by its very definition ($M_k $ is size $2^k \times 2^k$). This means we can divide it into four equal quadrants by dividing along the vertical and horizontal gaps between the middle rows and columns. Each quadrant will have sides of length $2^n$, since $M_{n+1}$ had sides of length $2^{n+1}$ and we divided each side-length in half to get $M_n$. \\
Now, regardless of where the single zero was initially placed, it must be in one and only one of these quadrants. Pick the other three quadrants that do not have a zero (consist of all ones). Place a single zero in the innermost component for each of the three quadrants that consist of all ones. What I mean by innermost are pieces touching the center of the matrix $M_{n+1}$, these 3 pieces form an L shape and thus this is a valid operation to perform. \\
Now, all of the 4 quadrants are of size $2^n \times 2^n$ and consist of all ones except a single zero, so we can apply $P(n)$. This means that each quadrant can be reduced to a zero matrix in a finite sequence of remove-L operations. Because it took us only a finite (single) valid operation (removing the L in the 3 one-filled quadrants) to get to this step from $M_{n+1}$, then the matrix $M_{n+1}$ can also be reduced to the zero matrix in a finite sequence of steps. Thus we assumed $P(n)$ and showed that this implies $P(n+1)$, concluding the proof. 
\end{homeworkProblem}


\newpage 



\begin{homeworkProblem}
Suppose you are given an array A of n distinct integers with the following property: There exists a unique index p such that the values of A[1...p] are increasing and the values of A[p...n] are is decreasing. \\
For instance, in the example below we have $n=10$ and $p=4$.
$$ A = [2, 5, 12, 17, 15, 10, 9, 4, 3, 1] $$ 

Design a O(log n) algorithm to find p given an array A with the above property. \\

\textbf{Algorithm : } \\
    Since the required run-time is $O(\log(n))$, I know that I have to find a way to reduce the search space for $p$ by a constant multiple for each call. I applied a slight change to the typical binary search algrorithm to accomplish this task. My algorithm looks not for a specific key, but instead how the two middle-elements compare to one another. If they are increasing (low to high index), then I recurse on the right half of the array, if they are decreasing I recurse on the left half. When I have only one element, I know that I have found the index of the number where the numbers change from increasing to decreasing. If I have narrowed it to two items, I can perform 2 comparisons to determine which one corresponds to $p$.  \\

        % This algorithm exploits the partial odering of the elements by using the fact that if any two pairs of adjacent elements are increasing, then the index $p$ must be to the right. Likewise, if they are decreasing, the index $p$ must be to the left. we look for the actual $p$ element when the left and right search indicies are either equal or one away from one another.  \\
    \problemAnswer{
        \texttt{// A = array of n elements, l = left element to sub-search} \\
        \texttt{//  r = right element to subsearch, return the index of p.} \\
        \texttt{ 1.} \texttt{ findp(A, l, r) } \\
        \texttt{ 2.} \texttt{ \tab i = (r+l)/2 // get middle element} \\
        \texttt{ 3.} \texttt{ \tab if l == r : // we found it} \\
        \texttt{ 4.} \texttt{ \tab \tab return r} \\
        \texttt{ 5.} \texttt{ \tab else if  r-l == 1 : // it's one of the two we are searching} \\
        \texttt{ 6.} \texttt{ \tab \tab if A[r] >= A[l] } \\
        \texttt{ 7.} \texttt{ \tab \tab \tab return r} \\
        \texttt{ 8.} \texttt{ \tab \tab else } \\
        \texttt{ 9.} \texttt{ \tab \tab \tab return l } \\
        \texttt{ 10.} \texttt{ \tab if A[i] >= A[i-1] // if increasing} \\
        \texttt{ 11.} \texttt{ \tab \tab return findp(A, i, r) // must be in right half} \\
        \texttt{ 12.} \texttt{\tab else} \\
        \texttt{ 13.} \texttt{ \tab \tab return findp(A, l, i) // must be in left half} \\
    }

\textbf{Proof of Correctness : } \\[.1in]

    To start, we must acknowledge that if an array holds the partial-sorting property given above, then so must any contiguous sub-section of that array. Any sub-section will contain elements either strictly to the left, strictly to the right, or on both sides of the $p$ index. Given the properties of the partial-sort this sub-section then must also contain items that are either strictly increasing, strictly decreasing, or increasing and then decreasing from some given point. This fact is used is the proof below. \\
    Let $P(n)$ be the statement `On any array (or sub-array) $A$ of size $n$ that contains the $p$ index, the \texttt{findp} algorithm will find that correct index.'.\\
    Notice that I explicitely am assuming the subarray contains the $p$ index in its bounds. This sets us up to show via induction that we can always choose correct sub-array to search for the $p$ index on the next recursive call. \\

    \textbf{Base Case : } \\
    There are two base cases, if the length of the sub-array we are searching is 1 or 2. Remember I am assuming that the $p$ index exists inside the bounds of the sub-array. \\
    $P(n = 1)$ : If the sub-array is of size one, then the correct index to return would be of the only element. \texttt{findp} will be called with $l = r$, which will be caught by the \texttt{if} statement on line 3 and $r$ would be returned, which is the item we are looking for. \\
    $P(n = 2)$ : If there are two elements in the sub-array, then the \texttt{else if} statement on line 5 with be caught. This will examine the two elements and return the right index if it is greater than or equal to the left and return the left index otherwise. Since a two-element sub-array must either be decreasing or increasing, this \texttt{else if} statement will return the correct index. \\
    \textbf{Inductive Case : } \\
    Assume for $n > 2$ that $P(k)$ is true for $k = [1 \ldots n]$, i.e. that the correct index $p$, if it exists, can be found for any given sub-array $A$ on $k$ items that is partially-sorted (as described above). I will use strong induction to show that this implies $P(n+1)$ is true. \\
    Take a given array $A$ on $n+1$ elements as that has the partial-sorting property. Since $n > 2$, $r > l+1$ so the first two $if$-statements don't execute. Now, it compares the middle two elements to eachother. If the right one is larger than the left then the $p$ index must be in right half of the array, otherwise the partial-sort property of the array would be invalid. If the two middle elemenets are decreasing, then the $p$ index must be in the left half of the array for the partial-sort property to hold. The algorithm then recurses on either $\left \lfloor{n/2}\right \rfloor$ or n- $\left \lfloor {n/2}\right \rfloor $ items depending on the outcome of the comparisons just described.. Since both of these numbers of items to recurse on are less than $n+1$, we can apply the inductive hypothesis on whichever half is taken. The inductive hypthesis says that the algorithm will be able to find the right $p$ index (given it exists) on any array from $k = [1 \ldots n]$. Since we know that the $p$ index is in one of the two halves of the initial array, and that we recurse on the currect half that is of size less than $n+1$, then the inductive hypothesis says the \texttt{findp} algorithm will correctly find the $p$ index. \\[.2in]


\textbf{Proof of Runtime Complexity : } \\
    I will now attempt to prove that the run-time complexity for the above algorithm is of order $\log(n)$. I am assuming that all inital input arrays are a length that is a power of two to simplify the proof. \\

    The \texttt{findp} takes an array $A$ of $n >= 1$ elements that is partially sorted in such a way that all elements increase up to a certain index $p$ and after that they all decrease. It also takes in a left and right index value between which the search will occur. For each call to the algorithm, we perform a constant number of comparisons, and for each recursive call we will be narrowing the search-space by about half. 
    This can be formalized by the following recurrence relation : \\

    for $n >= 1$ where $n$ is a power of 2 \\
    \[
    T(n) \left \{
      \begin{tabular}{c l}
      $= 1$ & \text{ if } n = 1 \\
      $= 3$ & \text{ if } n = 2 \\
      $\leq$ T(n/2) + 4 & \text{ if } $n>2$  \\
      \end{tabular}
    \right \}
    \]


    Let $P(n)$ be the statement `On any array of size $A$ of size $n$, the \texttt{findp} algorithm will find the index $p$ in at most $3*\lg(n)+1$ comparisons of array elements.'.

    \textbf{Base Case : } \\
        $P(n = 1)$ : If the array is of size one, \texttt{findp} will be called with $l = r = 1$, which will be caught by the \texttt{if} statement on line 3 and $r = 1$ would be returned. Only a single comparison is performed. Thus \# comparisons = 1, and $3*\lg(n)+1 = 3*0+1 = 1$. $1 \leq 1$ is true so this base case is confirmed. \\
        $P(n = 2)$ : If the array is of size 2, then in the worse case we need to perform 3 comparisons (lines 3, 5, and 6) to decide which of the two elements corresponds to the $p$ index. \# comp. = 3. $3 \leq 3*\lg(2)+4$, $3 \leq 3+4$ is true, so the second base case is confirmed.

    \textbf{Inductive Case : } \\
        Assume for $n > 2$ that $P(k)$ is true for $k$ in $[1 \ldots n-1$, i.e. that any given array or sub-array $A$ that is partially-sorted (as described above) on $k$ elements, the \texttt{findp} algorithm can find the correct $p$ index in at most $3*\lg(k)+4$ comparisons. Take an arbitray array $A$ of length $n$ that has the partial-sort property as described above a few times. Sicne it is a power of two, we will recurse on exactly half of the elements in the array, which will also be a power of two in length. Substituting into the recurrance relation given above.

        $$ T(n) = T(n/2)+4 $$
     $n/2$ is in the range $k = [1 \ldots n-1]$, so the inductive hypothesis is used
        $$ T(n) = 3\lg(n/2) + 4$$
        $$ T(n) = 3\lg(n) - 3\lg(2) + 4$$
        $$ T(n) = 3\lg(n) - 3 + 4$$
        $$ T(n) = 3\lg(n) + 1 $$
        $$ T(n) < 3\lg(n) + 4 $$

        Since order notation dicards constants and lower order terms, $T(n) = O(\log(n))$ as was required by the proof.
\end{homeworkProblem}



\begin{homeworkProblem}

\end{homeworkProblem}



\begin{homeworkProblem}
Let $f$ and $g$ be two functions defined on the natural numbers. \\
Show that 
$$max_{n\geq 0} \{f(n), g(n)\} = O(f(n)+g(n))$$
Using the definition of big-O notation.

\textbf{Answer : } \\[.2in]
Since $f$ and $g$ are defined over the natural numbers ($n > 0$), they are both non-negative functions. This implies the following :
$$f(n)+g(n) \geq f(n) \geq 0$$  
$$f(n)+g(n) \geq g(n) \geq 0$$
Since $max_{n\geq 0} \{f(n), g(n)\}$ is just the larger of $f$ and $g$, we get the following equation for $n \geq 0$ :
$$ f(n)+g(n) \geq max_{n\geq 0} \{f(n), g(n)\}$$

Thus $max_{n\geq 0} \{f(n), g(n)\} \leq c*f(n)+g(n)$ for all $n >= n_0$ where $n_0 = 1$ and $c = 1$, satisfying the definiton of big-O.
\end{homeworkProblem}

%----------------------------------------------------------------------------------------

\end{document}