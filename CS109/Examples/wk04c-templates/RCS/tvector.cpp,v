head	1.54;
access;
symbols;
locks;
comment	@// @;


1.54
date	2013.07.31.21.20.13;	author -;	state -;
branches;
next	1.53;

1.53
date	2013.07.31.20.59.27;	author -;	state -;
branches;
next	1.52;

1.52
date	2013.07.31.20.53.40;	author -;	state -;
branches;
next	1.51;

1.51
date	2013.07.31.20.50.42;	author -;	state -;
branches;
next	1.50;

1.50
date	2013.07.31.19.31.26;	author -;	state -;
branches;
next	1.49;

1.49
date	2013.07.31.19.30.19;	author -;	state -;
branches;
next	1.48;

1.48
date	2013.07.31.19.29.29;	author -;	state -;
branches;
next	1.47;

1.47
date	2013.07.31.19.26.17;	author -;	state -;
branches;
next	1.46;

1.46
date	2013.07.31.19.25.27;	author -;	state -;
branches;
next	1.45;

1.45
date	2013.07.31.19.23.58;	author -;	state -;
branches;
next	1.44;

1.44
date	2013.07.31.19.23.26;	author -;	state -;
branches;
next	1.43;

1.43
date	2013.07.31.19.17.19;	author -;	state -;
branches;
next	1.42;

1.42
date	2013.07.31.19.16.27;	author -;	state -;
branches;
next	1.41;

1.41
date	2013.07.31.19.15.49;	author -;	state -;
branches;
next	1.40;

1.40
date	2013.07.31.19.15.14;	author -;	state -;
branches;
next	1.39;

1.39
date	2013.07.31.03.16.56;	author -;	state -;
branches;
next	1.38;

1.38
date	2013.07.31.03.16.32;	author -;	state -;
branches;
next	1.37;

1.37
date	2013.07.31.03.16.00;	author -;	state -;
branches;
next	1.36;

1.36
date	2013.07.31.03.14.26;	author -;	state -;
branches;
next	1.35;

1.35
date	2013.07.31.03.13.46;	author -;	state -;
branches;
next	1.34;

1.34
date	2013.07.31.03.11.40;	author -;	state -;
branches;
next	1.33;

1.33
date	2013.07.31.03.07.08;	author -;	state -;
branches;
next	1.32;

1.32
date	2013.07.31.03.02.02;	author -;	state -;
branches;
next	1.31;

1.31
date	2013.07.31.03.01.30;	author -;	state -;
branches;
next	1.30;

1.30
date	2013.07.31.02.54.54;	author -;	state -;
branches;
next	1.29;

1.29
date	2012.05.19.02.35.38;	author -;	state -;
branches;
next	1.28;

1.28
date	2012.05.19.02.35.09;	author -;	state -;
branches;
next	1.27;

1.27
date	2012.05.19.02.34.42;	author -;	state -;
branches;
next	1.26;

1.26
date	2012.05.19.02.33.41;	author -;	state -;
branches;
next	1.25;

1.25
date	2012.05.19.02.32.49;	author -;	state -;
branches;
next	1.24;

1.24
date	2012.05.19.02.28.20;	author -;	state -;
branches;
next	1.23;

1.23
date	2012.05.19.01.38.53;	author -;	state -;
branches;
next	1.22;

1.22
date	2012.05.19.01.20.52;	author -;	state -;
branches;
next	1.21;

1.21
date	2012.05.18.21.34.10;	author -;	state -;
branches;
next	1.20;

1.20
date	2012.05.18.19.44.27;	author -;	state -;
branches;
next	1.19;

1.19
date	2012.05.18.19.43.02;	author -;	state -;
branches;
next	1.18;

1.18
date	2012.05.18.19.42.47;	author -;	state -;
branches;
next	1.17;

1.17
date	2012.05.18.19.41.19;	author -;	state -;
branches;
next	1.16;

1.16
date	2012.05.18.19.39.53;	author -;	state -;
branches;
next	1.15;

1.15
date	2012.05.18.19.39.24;	author -;	state -;
branches;
next	1.14;

1.14
date	2012.05.18.19.39.15;	author -;	state -;
branches;
next	1.13;

1.13
date	2012.05.18.19.29.42;	author -;	state -;
branches;
next	1.12;

1.12
date	2012.05.18.19.29.04;	author -;	state -;
branches;
next	1.11;

1.11
date	2012.05.18.19.28.46;	author -;	state -;
branches;
next	1.10;

1.10
date	2012.05.18.19.28.27;	author -;	state -;
branches;
next	1.9;

1.9
date	2012.05.18.05.56.30;	author -;	state -;
branches;
next	1.8;

1.8
date	2012.05.18.00.54.52;	author -;	state -;
branches;
next	1.7;

1.7
date	2012.05.17.23.57.55;	author -;	state -;
branches;
next	1.6;

1.6
date	2012.05.17.04.21.06;	author -;	state -;
branches;
next	1.5;

1.5
date	2012.05.17.02.16.36;	author -;	state -;
branches;
next	1.4;

1.4
date	2012.05.15.18.24.46;	author -;	state -;
branches;
next	1.3;

1.3
date	2012.05.15.02.41.39;	author -;	state -;
branches;
next	1.2;

1.2
date	2012.05.12.03.16.53;	author -;	state -;
branches;
next	1.1;

1.1
date	2012.05.12.03.16.33;	author -;	state -;
branches;
next	;


desc
@@


1.54
log
@-
@
text
@// $Id: tvector.cpp,v 1.53 2013-07-31 13:59:27-07 - - $

//
// Template class tvector showing implementation of a vector,
// with its iterators.
//

#include <iostream>
#include <stdexcept>
#include <string>

using namespace std;

/////////////////////////////////////////////////////////////////
// general utilities
/////////////////////////////////////////////////////////////////

template <typename first_t, typename second_t>
struct tpair {
   first_t first;
   second_t second;
   tpair (const first_t first, const second_t second):
               first(first), second(second) {}
   // Default ctor default initialization for primitives/pointers.
   // Other implicit members work except for pointer arguments.
   tpair(): first(first_t()), second(second_t()) {}
};


/////////////////////////////////////////////////////////////////
// interface tvector.h
/////////////////////////////////////////////////////////////////

template <typename T>
class tvector {
   public:
      typedef T value_type;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef ptrdiff_t difference_type;
      typedef size_t size_type;
      class iterator;
      friend class tvector<value_type>::iterator;
   private:
      size_t _size;
      size_t _capacity;
      pointer _data;

   public:
      tvector (const tvector&);
      tvector (tvector&&);
      tvector& operator= (const tvector&);
      tvector& operator= (tvector&&);
      ~tvector() { if (_data) delete[] _data; }

      explicit tvector (size_t size = 0);
      const_reference operator[] (size_t pos) const {
                  return _data[pos]; }
      reference operator[] (size_t pos) { return _data[pos]; }

      bool empty() const { return _size == 0; }
      size_t size() const { return _size; }
      size_t capacity() const { return _capacity; }
      void reserve (size_t capacity);

      void push_back (const_reference);
      void pop_back() { --_size; }
      const_reference back() const { return _data[_size - 1]; }
      reference back() { return _data[_size - 1]; }

      iterator begin() { return iterator (&_data[0]); }
      iterator end() { return iterator (&_data[_size]); }
};


template <typename value_type>
class tvector<value_type>::iterator {
   friend class tvector<value_type>;
   private:
      pointer value;
      iterator (pointer value): value(value) {};
   public:
      iterator(): value(NULL) {};
      iterator (const iterator&) = default;
      iterator& operator= (const iterator&) = default;
      // Copy and move same, since value is just a pointer.
      ~iterator() = default;
      iterator& operator++() { ++value; return *this; } // ++itor
      iterator operator++ (int); // itor++
      bool operator== (const iterator& that) const {
         return value == that.value;
      }
      bool operator!= (const iterator& that) const {
         return not (*this == that);
      }
      reference operator*() const { return *value; }
      pointer operator->() const { return value; }
};


/////////////////////////////////////////////////////////////////
// implementation tvector
/////////////////////////////////////////////////////////////////

template <typename value_type>
tvector<value_type>::tvector (size_t size):
            _size(size), _capacity(size), _data(NULL) {
   if (_capacity > 0) _data = new value_type[_capacity];
};

template <typename value_type>
tvector<value_type>::tvector (const tvector& that):
            _size(that.size), _capacity(that.size) {
   _data = new value_type[_size];
   std::copy (&that._data[0], &that._data[_size], _data);
}

template <typename value_type>
tvector<value_type>::tvector (tvector&& that):
            _size(that.size), _capacity(that.size), _data(that.data) {
   that._size = 0;
   that._capacity = 0;
   that._data = NULL;
}

template <typename value_type>
tvector<value_type>& 
tvector<value_type>::operator= (const tvector& that) {
   if (this == &that) return *this;
   if (capacity < that.size) {
      if (_data) delete[] _data;
      _capacity = that.size;
      _data = new value_type[capacity];
   }
   _size = that.size;
   std::copy (&that._data[0], &that._data[_size], _data);
   return *this;
}

template <typename value_type>
tvector<value_type>& tvector<value_type>::operator= (tvector&& that) {
   if (this == &that) return *this;
   if (_data) delete[] _data;
   _size = that._size;
   _capacity = that._capacity;
   _data = that._data;
   that._size = 0;
   that._capacity = 0;
   that._data = NULL;
   return *this;
}


template <typename value_type>
void tvector<value_type>::reserve (size_t capacity) {
   if (_capacity < capacity) {
      pointer olddata = _data;
      _capacity = capacity;
      _data = new value_type[_capacity];
      if (olddata != NULL) {
         std::copy (&olddata[0], &olddata[_size], _data);
         if (olddata) delete[] olddata;
      }
   }
}

template <typename value_type>
void tvector<value_type>::push_back (const_reference value) {
   if (_size == _capacity) reserve (2 * _capacity + 1);
   _data[_size++] = value;
}

template <typename value_type>
typename tvector<value_type>::iterator
tvector<value_type>::iterator::operator++(int) {
   iterator result = *this;
   ++value;
   return result;
}


/////////////////////////////////////////////////////////////////
// main program test harness
/////////////////////////////////////////////////////////////////

typedef tpair<string, int> sipair_t;
typedef tvector<sipair_t> vec_t;
typedef vec_t::iterator vecitor_t;

template <typename T1, typename T2>
ostream& operator<< (ostream& out, const tpair<T1,T2>& pair) {
   out << '[' << pair.first << ',' << pair.second << ']';
   return out;
}

int main (int argc, char** argv) {
   vec_t vec;
   for (int pos = 1; pos < argc; ++pos) {
      vec.push_back (sipair_t (argv[pos], pos));
   }
   for (vecitor_t itor = vec.begin(); itor != vec.end(); ++itor) {
      cout << *itor << endl;
   }
   return 0;
}

/*
//TEST// valgrind --leak-check=full --show-reachable=yes \
//TEST//       tvector this is some test data for the tvector \
//TEST//       >tvector.out 2>&1
//TEST// pstatus >>tvector.out
//TEST// mkpspdf tvector.ps tvector.cpp* tvector.out*
*/

@


1.53
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.52 2013-07-31 13:53:40-07 - - $
d24 1
a24 1
   // Default ctor default initialization for primitives & pointers.
d38 4
a41 4
      typedef value_type &reference;
      typedef const value_type &const_reference;
      typedef value_type *pointer;
      typedef const value_type *const_pointer;
d52 4
a55 4
      tvector (const tvector &);
      tvector (tvector &&);
      tvector &operator= (const tvector &);
      tvector &operator= (tvector &&);
d86 2
a87 2
      iterator (const iterator &) = default;
      iterator &operator= (const iterator &) = default;
d90 1
a90 1
      iterator &operator++() { ++value; return *this; } // ++itor
d92 1
a92 1
      bool operator== (const iterator &that) const {
d95 1
a95 1
      bool operator!= (const iterator &that) const {
d114 1
a114 1
tvector<value_type>::tvector (const tvector &that):
d121 1
a121 1
tvector<value_type>::tvector (tvector &&that):
d129 2
a130 2
tvector<value_type> &
tvector<value_type>::operator= (const tvector &that) {
d143 1
a143 1
tvector<value_type> &tvector<value_type>::operator= (tvector &&that) {
d193 1
a193 1
ostream &operator<< (ostream &out, const tpair<T1,T2> &pair) {
d198 1
a198 1
int main (int argc, char **argv) {
@


1.52
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.51 2013-07-31 13:50:42-07 - - $
d95 3
@


1.51
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.50 2013-07-31 12:31:26-07 - - $
a65 1
      void resize (size_t size);
a153 6
void tvector<value_type>::resize (size_t size) {
   if (size < _size) reserve (size);
   _size = size;
}

template <typename value_type>
@


1.50
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.49 2013-07-31 12:30:19-07 - - $
a95 3
      bool operator!= (const iterator &that) const {
         return not (*this == that);
      }
@


1.49
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.48 2013-07-31 12:29:29-07 - - $
d220 1
@


1.48
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.47 2013-07-31 12:26:17-07 - - $
a217 1
//TEST//       --log-file=tvector.out.grind \
@


1.47
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.46 2013-07-31 12:25:27-07 - - $
d199 6
d211 1
a211 1
      cout << itor->first << ", " << itor->second << endl;
@


1.46
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.45 2013-07-31 12:23:58-07 - - $
d178 1
a178 3
   if (_size == _capacity) {
      reserve (2 * _capacity + 1);
   }
@


1.45
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.44 2013-07-31 12:23:26-07 - - $
d70 1
a70 1
      void pop_back();
a184 5
void tvector<value_type>::pop_back() {
   --size;
}

template <typename value_type>
@


1.44
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.43 2013-07-31 12:17:19-07 - - $
d118 1
a118 1
   copy (&that._data[0], &that._data[_size], _data);
d139 1
a139 1
   copy (&that._data[0], &that._data[_size], _data);
d170 1
a170 1
         copy (&olddata[0], &olddata[_size], _data);
@


1.43
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.42 2013-07-31 12:16:27-07 - - $
a49 1
      void copydata (pointer data);
a108 7
void tvector<value_type>::copydata (pointer data) {
   for (size_t pos = 0; pos < _size; ++pos) {
      _data[pos] = data[pos];
   }
}

template <typename value_type>
d118 1
a118 1
   copydata (that._data);
d139 1
a139 1
   copydata (that._data);
d170 1
a170 1
         copydata (olddata);
@


1.42
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.41 2013-07-31 12:15:49-07 - - $
d75 1
a75 1
      iterator begin() { return iterator (_data); }
@


1.41
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.40 2013-07-31 12:15:14-07 - - $
d76 1
a76 1
      iterator end() { return iterator (_data + _size); }
@


1.40
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.39 2013-07-30 20:16:56-07 - - $
d26 1
a26 1
   tpair (): first(first_t()), second(second_t()) {}
d64 3
a66 3
      bool empty () const { return _size == 0; }
      size_t size () const { return _size; }
      size_t capacity () const { return _capacity; }
d91 1
a91 1
      ~iterator () = default;
@


1.39
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.38 2013-07-30 20:16:32-07 - - $
d23 3
a25 1
                first(first),        second(second) {}
d34 1
a34 1
template <typename value_t>
d36 10
d49 2
a50 2
      value_t *_data;
      void copydata (value_t *data);
d60 3
a62 6
      const value_t &operator[] (size_t pos) const { // x = a[i];
         return _data[pos];
      }
      value_t &operator[] (size_t pos) { // a[i] = x;
         return _data[pos];
      }
d70 1
a70 1
      void push_back (const value_t &);
d72 2
a73 2
      const value_t &back() const { return _data[_size - 1]; }
      value_t &back() { return _data[_size - 1]; }
a74 2
      class iterator;
      friend class tvector<value_t>::iterator;
d80 3
a82 3
template <typename value_t>
class tvector<value_t>::iterator {
   friend class tvector<value_t>;
d84 2
a85 2
      value_t *value;
      iterator (value_t *value): value(value) {};
d100 2
a101 2
      value_t &operator*() const { return *value; }
      value_t *operator->() const { return value; }
d109 2
a110 2
template <typename value_t>
void tvector<value_t>::copydata (value_t *data) {
d116 2
a117 2
template <typename value_t>
tvector<value_t>::tvector (size_t size):
d119 1
a119 1
   if (_capacity > 0) _data = new value_t[_capacity];
d122 2
a123 2
template <typename value_t>
tvector<value_t>::tvector (const tvector &that):
d125 1
a125 1
   _data = new value_t[_size];
d129 2
a130 2
template <typename value_t>
tvector<value_t>::tvector (tvector &&that):
d137 3
a139 2
template <typename value_t>
tvector<value_t> &tvector<value_t>::operator= (const tvector &that) {
d144 1
a144 1
      _data = new value_t[capacity];
d151 2
a152 2
template <typename value_t>
tvector<value_t> &tvector<value_t>::operator= (tvector &&that) {
d165 2
a166 2
template <typename value_t>
void tvector<value_t>::resize (size_t size) {
d171 2
a172 2
template <typename value_t>
void tvector<value_t>::reserve (size_t capacity) {
d174 1
a174 1
      value_t *olddata = _data;
d176 1
a176 1
      _data = new value_t[_capacity];
d184 2
a185 2
template <typename value_t>
void tvector<value_t>::push_back (const value_t &value) {
d192 2
a193 2
template <typename value_t>
void tvector<value_t>::pop_back() {
d197 3
a199 3
template <typename value_t>
typename tvector<value_t>::iterator
tvector<value_t>::iterator::operator++(int) {
@


1.38
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.37 2013-07-30 20:16:00-07 - - $
d197 1
@


1.37
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.36 2013-07-30 20:14:26-07 - - $
a188 1

@


1.36
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.35 2013-07-30 20:13:46-07 - - $
d48 6
a53 2
      const value_t &operator[] (size_t pos) const; // x = a[i];
      value_t &operator[] (size_t pos); // a[i] = x;
d156 1
a156 10
template <typename value_t>
const value_t &tvector<value_t>::operator[] (size_t pos) const {
   return _data[pos];
}

template <typename value_t>
value_t &tvector<value_t>::operator[] (size_t pos) {
   return _data[pos];
}

d189 1
@


1.35
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.34 2013-07-30 20:11:40-07 - - $
d68 1
d93 1
@


1.34
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.33 2013-07-30 20:07:08-07 - - $
d181 3
a183 1
   if (_size == _capacity) reserve (2 * _capacity);
@


1.33
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.32 2013-07-30 20:02:02-07 - - $
a38 1
      static const size_t RESERVE = 8;
d105 2
a106 2
            _size(size), _capacity(size) {
   _data = new value_t[_capacity];
a167 1
   if (capacity < RESERVE) capacity = RESERVE;
@


1.32
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.31 2013-07-30 20:01:30-07 - - $
d46 1
a46 1
      ~tvector() {delete[] _data;}
d118 8
d129 1
a129 1
      delete[] _data;
d139 13
d176 1
a176 1
         delete[] olddata;
@


1.31
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.30 2013-07-30 19:54:54-07 - - $
d27 1
@


1.30
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.5 2013-07-29 13:57:32-07 - - $
d34 1
a35 1
      size_t _size;
a40 1
      tvector(): _capacity(0), _size(0), _data(NULL) {}
a170 17
const value_t &tvector<value_t>::back() const {
   return _data[_size - 1];
}

template <typename value_t>
value_t &tvector<value_t>::back() {
   return _data[_size - 1];
}

template <typename value_t>
typename tvector<value_t>::iterator &
tvector<value_t>::iterator::operator++() {
   ++value;
   return *this;
}

template <typename value_t>
@


1.29
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.28 2012-05-18 19:35:09-07 - - $
d18 1
a18 1
template <typename one_t, typename two_t>
d20 5
a24 4
   one_t one;
   two_t two;
   tpair (const one_t _one, const two_t _two): one(_one), two(_two) {}
   tpair (): one(one_t()), two(two_t()) {}
a26 1

a30 3
template <typename, typename>
class tvector_iterator;

d34 1
a34 1
      typedef tvector<value_t> this_t;
a35 1
      size_t _capacity;
d37 2
a38 4
      void range_check (size_t);
      void empty_check();
      void copy_data (value_t *data);
      static const size_t MIN_RESERVE = 8;
d41 1
a41 5
      friend class tvector_iterator<this_t, value_t>;
      typedef tvector_iterator<this_t, value_t> iterator;

      // Override default members.
      inline tvector(): _size(0), _capacity(0), _data(NULL) {};
d43 1
d45 2
a46 1
      inline ~tvector() {delete[] _data;}
d48 1
a48 4
      // Other ctors.
      explicit tvector (size_t size);

      // Checked subscripting.
d52 3
a54 4
      // Size and capacity checks and adjustments.
      inline bool empty() const {return _size == 0;}
      inline size_t size() const {return _size;}
      inline size_t capacity() const {return _capacity;}
a57 1
      // End access and adjustment.
d60 2
a61 2
      const value_t &back() const;
      value_t &back();
d63 4
a66 4
      // Iterator creation.
      iterator begin() {return iterator (this, 0);}
      iterator end() {return iterator (this, _size);}
      
d69 3
a71 7

/////////////////////////////////////////////////////////////////
// interface tvector::iterator
/////////////////////////////////////////////////////////////////

template <typename vector_t, typename value_t>
class tvector_iterator {
d73 2
a74 4
      vector_t *_vector;
      size_t _pos;
      tvector_iterator (vector_t *vector, size_t pos);
      friend class tvector<value_t>;
d76 15
a90 12
      template <typename vec_t, typename val_t>
      friend ostream &operator<< (
         ostream&, const tvector_iterator<vec_t, val_t> &
      );
      inline tvector_iterator(): _vector(NULL), _pos(0) {}
      // Copy ctor, op=, and dtor accepted as default,
      tvector_iterator &operator++(); // ++itor
      tvector_iterator operator++ (int); // itor++
      bool operator== (const tvector_iterator &) const;
      bool operator!= (const tvector_iterator &) const;
      value_t &operator*() const;
      value_t *operator->() const;
a92 1

a96 13
// void range_check (size_t);
template <typename value_t>
void tvector<value_t>::range_check (size_t pos) {
   if (pos >= _size) throw out_of_range ("tvector::range_check");
}

// void empty_check();
template <typename value_t>
void tvector<value_t>::empty_check() {
   if (empty()) throw out_of_range ("tvector::empty_check");
}

// void copy_data (value_t *data);
d98 1
a98 1
void tvector<value_t>::copy_data (value_t *data) {
d104 6
a109 1
// tvector (const tvector &);
d112 3
a114 6
_size(that.size), _capacity(that.size) {
   if (_size == 0) _data = NULL;
   else {
      _data = new value_t[_size];
      copy_data (that._data);
   }
a116 1
// tvector &operator= (const tvector &);
d119 5
a123 8
   if (this != &that) {
      if (_capacity < that._size) {
         delete[] _data;
         _capacity = that._size;
         _data = new value_t[_capacity];
      }
      _size = that._size;
      copy_data (that._data);
d125 2
a129 10
// explicit tvector (size_t size);
template <typename value_t>
tvector<value_t>::tvector (size_t size): _size(size), _capacity(size) {
   if (_size == 0) _data = NULL;
              else _data = new value_t[_size];
   // What about unitialized value_t?
}


// const value_t &operator[] (size_t pos) const; // x = a[i];
a131 1
   range_check (pos);
a134 1
// value_t &operator[] (size_t pos); // a[i] = x;
a136 1
   range_check (pos);
a139 1
// void resize (size_t size);
d142 1
a142 2
   if (_size < size) reserve (size);
   // What about uninitialized elements?
a145 1
// void reserve (size_t capacity);
d148 1
a148 1
   if (capacity < MIN_RESERVE) capacity = MIN_RESERVE;
d150 1
a150 1
      value_t *old_data = _data;
d153 3
a155 4
      if (old_data != NULL) {
         copy_data (old_data);
         delete[] old_data;
         // What about uninitialized elements?
a159 2

// void push_back (const value_t &);
d162 1
a162 2
   if (_data == NULL) reserve (MIN_RESERVE);
   else if (_size == _capacity) reserve (2 * _capacity);
a165 1
// void pop_back();
d168 1
a168 2
   empty_check();
   --_size;
a170 1
// const value_t &back() const;
a172 1
   empty_check();
a175 1
// value_t &back();
a177 1
   empty_check();
d181 4
a184 26

/////////////////////////////////////////////////////////////////
// implementation tvector_iterator
/////////////////////////////////////////////////////////////////

template <typename vector_t, typename value_t>
ostream &operator<< (ostream &out, const tvector_iterator<vector_t,
value_t> &it) {
   cout << it._vector << "[" << it._pos << "]";
   return out;
}

// tvector_iterator (vector_t vector, size_t pos);
// called from tvector::begin and tvector::end.
template <typename vector_t, typename value_t>
tvector_iterator<vector_t, value_t>::tvector_iterator (
   vector_t *vector, size_t pos
): _vector(vector), _pos(pos) {
}

// tvector_iterator &operator++(); // ++itor
template <typename vector_t, typename value_t>
tvector_iterator<vector_t, value_t> &
tvector_iterator<vector_t, value_t>::operator++() {
   _vector->range_check (_pos);
   ++_pos;
d188 5
a192 7
// tvector_iterator operator++ (int); // itor++
template <typename vector_t, typename value_t>
tvector_iterator<vector_t, value_t>
tvector_iterator<vector_t, value_t>::operator++ (int) {
   tvector_iterator<vector_t, value_t> result (*this);
   _vector->range_check (_pos);
   ++_pos;
a195 31
// bool operator== (const tvector_iterator &) const;
template <typename vector_t, typename value_t>
bool tvector_iterator<vector_t, value_t>::operator== (
   const tvector_iterator<vector_t, value_t> &that
) const {
   return _vector == that._vector && _pos == that._pos;
}

// bool operator!= (const tvector_iterator &) const;
template <typename vector_t, typename value_t>
bool tvector_iterator<vector_t, value_t>::operator!= (
   const tvector_iterator<vector_t, value_t> &that
) const {
   return ! (*this == that);
}


// value_t &operator*() const;
template <typename vector_t, typename value_t>
value_t &tvector_iterator<vector_t, value_t>::operator*() const {
   _vector->range_check (_pos);
   return _vector->_data[_pos];
}

// value_t *operator->() const;
template <typename vector_t, typename value_t>
value_t *tvector_iterator<vector_t, value_t>::operator->() const {
   _vector->range_check (_pos);
   return &_vector->_data[_pos];
}

d210 1
a210 1
      cout << itor->one << ", " << itor->two << endl;
@


1.28
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.27 2012-05-18 19:34:42-07 - - $
d292 1
@


1.27
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.26 2012-05-18 19:33:41-07 - - $
d207 1
@


1.26
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.25 2012-05-18 19:32:49-07 - - $
d168 1
@


1.25
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.23 2012-05-18 18:38:53-07 - - $
d323 8
@


1.24
log
@-
@
text
@d23 1
d78 1
a78 3
      iterator end() {cout<<"end"<<_size<<endl;return iterator (this, _size);}
      const_iterator begin() const {return const_iterator (this, 0);}
      const_iterator end() const {cout<<"end"<<_size<<endl;return const_iterator (this, _size);}
d99 1
a99 1
      inline tvector_iterator(): _vector(NULL), _pos(0) {cout<<"NULL"<<endl;}
a210 1
cout<<"back:"<<_size<< " "<<value<<endl;
a252 1
cout<<"tvivp:"<<vector<<" "<<pos<<endl;
a278 1
cout<<"=="<<_vector<<" "<<_pos<<" "<<that._vector<<" " <<that._pos<<endl;
d287 1
a287 3
cout<<_pos<<that._pos<<endl;
cout<<"!="<<_vector<<" "<<_pos<<" "<<that._vector<<" " <<that._pos<<endl;
   return _vector != that._vector || _pos != that._pos;
a307 1
/*
d310 1
a310 1
typedef vec_t::const_iterator vecitor_t;
a321 20
*/


typedef tvector<int> vec_t;
typedef vec_t::iterator vecitor_t;

int main (int argc, char **argv) {
   vec_t vec;
   for (int pos = 1; pos < argc; ++pos) {
      vec.push_back (pos);
   }
   vecitor_t itor = vec.begin();
   cout << "itor:"<< itor << endl;
   vecitor_t end = vec.end();
   cout << "end:"<<end << endl;
   for (; itor != end; ++itor) {
      cout << *itor << endl;
   }
   return 0;
}
@


1.23
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.20 2012-05-18 12:44:27-07 - - $
a46 1
      friend class tvector_iterator<this_t, const value_t>;
a47 1
      typedef tvector_iterator<this_t, const value_t> const_iterator;
d77 1
a77 1
      iterator end() {return iterator (this, _size);}
d79 1
a79 1
      const_iterator end() const {return const_iterator (this, _size);}
d96 5
a100 1
      inline tvector_iterator(): _vector(NULL), _pos(0) {};
a107 3
      operator tvector_iterator<vector_t, const value_t>() {
         return tvector_iterator<vector_t, const value_t> ();
      }
d212 1
d242 7
d255 1
d282 1
d291 3
a293 1
   return ! (*this == that);
d333 1
a333 1
typedef vec_t::const_iterator vecitor_t;
d335 1
a335 1
int main (int argc, char **) {
d340 5
a344 1
   for (vecitor_t itor = vec.begin(); itor != vec.end(); ++itor) {
@


1.22
log
@-
@
text
@d47 1
@


1.21
log
@-
@
text
@a17 5
template <typename any_t>
inline bool operator!= (const any_t &one, const any_t &two) {
   return ! (one == two);
}

d43 1
a43 1
      static const int MIN_RESERVE = 8;
d94 1
a94 1
      tvector_iterator (vector_t vector, size_t pos);
d102 1
d105 3
d196 1
a196 1
      value_t old_data = _data;
d245 1
a245 1
   vector_t vector, size_t pos
d276 8
d323 1
a323 1
int main (int argc, char **argv) {
d328 1
a328 1
   for (vecitor_t itor (vec.begin()); itor != vec.end(); ++itor) {
@


1.20
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.19 2012-05-18 12:43:02-07 - - $
d35 3
a50 1
      template <typename, typename> class tvector_iterator;
d295 1
d308 17
@


1.19
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.18 2012-05-18 12:42:47-07 - - $
d10 1
@


1.18
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.17 2012-05-18 12:41:19-07 - - $
d298 1
a298 1
   for (size_t pos = 1; pos < argc; ++pos) {
@


1.17
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.16 2012-05-18 12:39:53-07 - - $
d296 1
a296 1
int main (int argc, char argv) {
d298 1
a298 1
   for (int pos = 1; pos < argc; ++pos) {
@


1.16
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.15 2012-05-18 12:39:24-07 - - $
d292 2
a293 1
typedef tvector<tpair<string, int> > vec_t;
d299 1
a299 1
      vec.push_back (tpair (argv[pos], pos));
@


1.15
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.14 2012-05-18 12:39:15-07 - - $
d292 1
a292 1
typedef vector<tpair<string, int> > vec_t;
@


1.14
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.13 2012-05-18 12:29:42-07 - - $
d22 1
a22 1
template <typename one_t, typname two_t>
@


1.13
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.12 2012-05-18 12:29:04-07 - - $
d22 7
d288 17
@


1.12
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.10 2012-05-18 12:28:27-07 - - $
d198 1
a198 1
// void push_back (const value_t &item);
d200 1
a200 1
void tvector<value_t>::push_back (const value_t &) {
d203 1
a203 1
   _data[_size++] = item;
@


1.11
log
@-
@
text
@d74 1
a74 1
      const_iterator begin() const {return const_iterator (this, 0)}
@


1.10
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.9 2012-05-17 22:56:30-07 - - $
d37 1
a37 1
      inline static const int MIN_RESERVE = 8;
@


1.9
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.8 2012-05-17 17:54:52-07 - - $
d35 3
d46 1
a46 1
      tvector(): _size(0), _capacity(0), _data(NULL) {};
d49 1
a49 1
      ~tvector() { delete[] _data; }
d59 3
a61 2
      size_t size() const { return _size; }
      size_t capacity() const { return _capacity; }
d72 4
a75 4
      iterator begin();
      iterator end();
      const_iterator begin() const;
      const_iterator end() const;
d92 1
a92 1
      tvector_iterator(): _vector(NULL), _pos(0) {};
d103 1
a103 1
// implementation tvector_iterator
d106 4
a109 5
// tvector_iterator (vector_t vector, size_t pos);
// called from tvector::begin and tvector::end.
template <typename vector_t, typename value_t>
tvector_iterator<vector_t, value_t>::tvector_iterator
(vector_t vector, size_t pos): _vector(vector), _pos(pos) {
d112 4
a115 32
// tvector_iterator &operator++(); // ++itor
template <typename vector_t, typename value_t>
tvector_iterator<vector_t, value_t> &
tvector_iterator<vector_t, value_t>::operator++() {
   _vector->range_check (_pos);
   ++_pos;
   return *this;
}

// tvector_iterator operator++ (int); // itor++
template <typename vector_t, typename value_t>
tvector_iterator<vector_t, value_t>
tvector_iterator<vector_t, value_t>::operator++ (int) {
   tvector_iterator<vector_t, value_t> result (*this);
   _vector->range_check (_pos);
   ++_pos;
   return result;
}

// bool operator== (const tvector_iterator &) const;
template <typename vector_t, typename value_t>
bool tvector_iterator<vector_t, value_t>::operator== (
   const tvector_iterator<vector_t, value_t> &that
) const {
   return _vector == that._vector && _pos == that._pos;
}

// value_t &operator*() const;
template <typename vector_t, typename value_t>
value_t &tvector_iterator<vector_t, value_t>::operator*() const {
   _vector->range_check (_pos);
   return _vector->_data[_pos];
d118 1
a118 13
// value_t *operator->() const;
template <typename vector_t, typename value_t>
value_t *tvector_iterator<vector_t, value_t>::operator->() const {
   _vector->range_check (_pos);
   return &_vector->_data[_pos];
}


/////////////////////////////////////////////////////////////////
// implementation tvector
/////////////////////////////////////////////////////////////////

// void range_check (size_t);
d120 4
a123 2
void tvector<value_t>::range_check (size_t pos) {
   if (pos >= _size) throw out_of_range ("tvector::range_check");
d133 1
a133 3
      for (size_t pos = 0; pos < _size; ++pos) {
         _data[pos] = that._data[pos];
      }
d147 1
a147 3
      for (size_t pos = 0; pos < _size; ++pos) {
         _data[pos] = that._data[pos];
      }
d178 1
a178 1
   // What about extra uninitialized elements?
d185 1
d187 8
d198 83
@


1.8
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.7 2012-05-17 16:57:55-07 - - $
d14 10
d97 5
a151 10
// general utilities
/////////////////////////////////////////////////////////////////

template <typename any_t>
inline bool operator!= (const any_t &one, const any_t &two) {
   return ! (one == two);
}


/////////////////////////////////////////////////////////////////
@


1.7
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.6 2012-05-16 21:21:06-07 - - $
d11 2
d27 2
d74 2
a75 2
      value_t *_curr;
      tvector_iterator (vector_t vector, value_t curr);
d78 1
a78 1
      tvector_iterator(): _vector(NULL), _curr(NULL) {};
d83 2
a84 3
      bool operator!= (const tvector_iterator &) const;
      value_t &operator*() const { return *_curr; }
      value_t *operator->() const { return _curr; }
d87 8
d98 3
a100 1
   return ++_curr;
d103 1
d107 3
a109 2
   tvector_iterator<vector_t, value_t> result (_curr);
   ++_curr;
d113 1
d115 4
a118 3
bool
tvector_iterator<vector_t, value_t>::operator== (const tvector_iterator<vector_t, value_t> &that) const {
   return _curr == that._curr;
d121 15
d150 7
d159 40
a198 1
            _size(that._size), _capacity (_size) {
d201 1
d203 3
a205 2
typename tvector<value_t>::tvector &
tvector<value_t>::operator= (const tvector &that) {
d207 16
@


1.6
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.3 2012-05-14 19:41:39-07 - - $
d18 1
d25 2
a26 3
      template <typename itvalue_t> class tvec_iterator;
      typedef tvec_iterator<value_t *> iterator;
      typedef tvec_iterator<const value_t *> const_iterator;
d29 1
a29 1
      tvector(): _size(0), _capacity(0), _data(0) {};
d32 1
a32 1
      ~tvector() {delete[] _data; }
d66 6
a71 3
template <typename value_t>
template <typename itvalue_t>
class tvector<value_t>::tvec_iterator<itvalue_t> {
d73 2
a74 4
   private:
      itvalue_t *_curr;
      tvec_iterator(); // Not implemented.
      tvec_iterator (value_t *curr): _curr(curr) {};
d76 4
a79 6
      // and share the underlying vector's data.
   public:
      tvec_iterator &operator++(); // ++itor
      tvec_iterator operator++ (int); // itor++
      bool operator== (const tvec_iterator &) const;
      bool operator!= (const tvec_iterator &) const;
d81 1
a81 1
      value_t *operator->() const { return *_curr; }
d84 3
a86 3
template <typename value_t>
typename tvector<value_t>::iterator &
tvector<value_t>::iterator::operator++() {
d90 4
a93 4
template <typename value_t>
typename tvector<value_t>::iterator
tvector<value_t>::iterator::operator++ (int) {
   iterator result (_curr);
d98 4
a101 4
template <typename value_t>
bool tvector<value_t>::iterator::operator==
(const iterator &that) const {
   return ! (_curr != that._curr);
d104 7
a110 4
template <typename value_t>
bool tvector<value_t>::iterator::operator!=
(const iterator &that) const {
   return _curr != that._curr;
d120 1
a120 1
_size(that._size), _capacity (_size) {
@


1.5
log
@-
@
text
@d69 1
a71 1
      friend class tvector;
@


1.4
log
@-
@
text
@d15 1
a15 1
template <typename item_t>
d20 1
a20 1
      item_t *_data;
d24 3
a26 5
      template <typename ptr_t> class t_iterator;
      //friend class t_iterator<item_t *>;
      //friend class t_iterator<const item_t *>;
      typedef t_iterator<item_t *> iterator;
      typedef t_iterator<const item_t *> const_iterator;
d38 2
a39 2
      const item_t &operator[] (size_t pos) const; // x = a[i];
      item_t &operator[] (size_t pos); // a[i] = x;
d48 1
a48 1
      void push_back (const item_t &);
d50 2
a51 2
      const item_t &back() const;
      item_t &back();
d55 1
a55 1
      iterator end() { return iterator (_data + _size); }
d57 1
a57 1
      const_iterator end() const { return const_iterator (_data + _size); }
d66 3
a68 2
template <typename vec, typename ptr_t>
class tvector<item_t>::t_iterator<ptr_t> {
d70 1
a70 1
      ptr_t _curr;
d72 2
a73 2
      t_iterator(); // Not implemented.
      t_iterator (item_t *curr): _curr(curr) {};
d77 6
a82 6
      t_iterator &operator++(); // ++itor
      t_iterator operator++ (int); // itor++
      bool operator== (const t_iterator &) const;
      bool operator!= (const t_iterator &) const;
      item_t &operator*() const { return *_curr; }
      item_t *operator->() const { return *_curr; }
d85 3
a87 7
//iterator &tvector<item_t>::iterator::operator++() {
//tvector<item_t>::iterator &tvector<item_t>::iterator::operator++() {
//iterator &tvector<item_t>::operator++() {

template <typename item_t>
typename tvector<item_t>::iterator &
tvector<item_t>::iterator::operator++() {
d91 3
a93 3
template <typename item_t>
typename tvector<item_t>::iterator
tvector<item_t>::iterator::operator++ (int) {
d99 2
a100 2
template <typename item_t>
bool tvector<item_t>::iterator::operator==
d105 2
a106 2
template <typename item_t>
bool tvector<item_t>::iterator::operator!=
d116 2
a117 2
template <typename item_t>
tvector<item_t>::tvector (const tvector &that):
d121 3
a123 3
template <typename item_t>
typename tvector<item_t>::tvector &
tvector<item_t>::operator= (const tvector &that) {
@


1.3
log
@-
@
text
@d1 1
a1 1
// $Id: tvector.cpp,v 1.1 2012-05-11 20:16:33-07 - - $
d24 5
a28 4
      class t_iterator;
      friend class t_iterator;
      typedef t_iterator<item_t> iterator;
      typedef t_iterator<const item_t> const_iterator;
d68 2
a69 2
template <typename item_t, typename itor_t>
class tvector<item_t>::iterator<itor_t> {
d71 1
a71 1
      item_t *_curr;
d73 2
a74 2
      iterator(); // Not implemented.
      iterator (item_t *curr): _curr(curr) {};
d78 4
a81 4
      iterator &operator++(); // ++itor
      iterator operator++ (int); // itor++
      bool operator== (const iterator &) const;
      bool operator!= (const iterator &) const;
@


1.2
log
@-
@
text
@d5 1
a5 3
// with its iterator.  Subscripts are checked, but iterators
// are not checked for being dangling.  For simplicity, we
// do not provide a const_iterator.
d12 1
a12 1
// interface tcvector.h
d24 4
a27 2
      class iterator;
      friend class iterator;
d55 4
a58 2
      iterator begin() const;
      iterator end() const;
d62 1
d64 1
a64 1
// interface tcvector::iterator
d67 2
a68 2
template <typename item_t>
class tvector<item_t>::iterator {
d81 2
a82 2
      item_t &operator*() const;
      item_t *operator->() const;
d85 4
d90 2
a91 1
tvector<item_t>::iterator &operator++() {
d95 34
@


1.1
log
@-
@
text
@d1 1
a1 1
// $Id$
d83 1
a83 1
tvector<item_t>::iterator iterator &operator++() {
@
