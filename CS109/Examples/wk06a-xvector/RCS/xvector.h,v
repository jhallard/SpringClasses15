head	1.46;
access;
symbols;
locks;
comment	@ * @;


1.46
date	2015.02.03.21.06.33;	author -;	state -;
branches;
next	1.45;

1.45
date	2014.07.09.19.47.57;	author -;	state -;
branches;
next	1.44;

1.44
date	2014.07.09.19.31.00;	author -;	state -;
branches;
next	1.43;

1.43
date	2014.07.09.05.41.25;	author -;	state -;
branches;
next	1.42;

1.42
date	2014.05.30.02.02.56;	author -;	state -;
branches;
next	1.41;

1.41
date	2014.05.05.22.56.04;	author -;	state -;
branches;
next	1.40;

1.40
date	2013.08.21.20.53.50;	author -;	state -;
branches;
next	1.39;

1.39
date	2013.08.20.02.03.59;	author -;	state -;
branches;
next	1.38;

1.38
date	2013.08.20.00.27.20;	author -;	state -;
branches;
next	1.37;

1.37
date	2013.08.17.01.47.27;	author -;	state -;
branches;
next	1.36;

1.36
date	2013.08.17.01.40.48;	author -;	state -;
branches;
next	1.35;

1.35
date	2013.08.17.01.34.54;	author -;	state -;
branches;
next	1.34;

1.34
date	2013.08.17.00.40.17;	author -;	state -;
branches;
next	1.33;

1.33
date	2013.08.16.21.57.39;	author -;	state -;
branches;
next	1.32;

1.32
date	2013.08.16.20.29.25;	author -;	state -;
branches;
next	1.31;

1.31
date	2013.08.16.19.48.11;	author -;	state -;
branches;
next	1.30;

1.30
date	2013.08.16.19.38.32;	author -;	state -;
branches;
next	1.29;

1.29
date	2013.08.16.02.05.24;	author -;	state -;
branches;
next	1.28;

1.28
date	2013.08.16.01.35.38;	author -;	state -;
branches;
next	1.27;

1.27
date	2013.08.16.01.05.07;	author -;	state -;
branches;
next	1.26;

1.26
date	2013.08.16.01.00.27;	author -;	state -;
branches;
next	1.25;

1.25
date	2013.08.16.00.38.59;	author -;	state -;
branches;
next	1.24;

1.24
date	2013.08.15.02.50.55;	author -;	state -;
branches;
next	1.23;

1.23
date	2013.08.15.02.49.48;	author -;	state -;
branches;
next	1.22;

1.22
date	2013.08.15.02.47.19;	author -;	state -;
branches;
next	1.21;

1.21
date	2013.08.15.02.15.37;	author -;	state -;
branches;
next	1.20;

1.20
date	2013.08.15.01.33.10;	author -;	state -;
branches;
next	1.19;

1.19
date	2013.08.15.01.31.16;	author -;	state -;
branches;
next	1.18;

1.18
date	2013.08.14.21.52.06;	author -;	state -;
branches;
next	1.17;

1.17
date	2013.08.14.21.39.32;	author -;	state -;
branches;
next	1.16;

1.16
date	2013.08.14.21.16.03;	author -;	state -;
branches;
next	1.15;

1.15
date	2013.08.14.02.07.31;	author -;	state -;
branches;
next	1.14;

1.14
date	2013.08.14.01.42.53;	author -;	state -;
branches;
next	1.13;

1.13
date	2013.08.14.01.37.27;	author -;	state -;
branches;
next	1.12;

1.12
date	2013.08.14.00.27.16;	author -;	state -;
branches;
next	1.11;

1.11
date	2013.08.13.23.53.23;	author -;	state -;
branches;
next	1.10;

1.10
date	2013.08.13.21.53.57;	author -;	state -;
branches;
next	1.9;

1.9
date	2013.08.13.01.55.17;	author -;	state -;
branches;
next	1.8;

1.8
date	2013.08.12.21.58.55;	author -;	state -;
branches;
next	1.7;

1.7
date	2013.08.12.21.50.01;	author -;	state -;
branches;
next	1.6;

1.6
date	2013.08.08.19.03.25;	author -;	state -;
branches;
next	1.5;

1.5
date	2013.08.07.20.45.39;	author -;	state -;
branches;
next	1.4;

1.4
date	2013.08.07.20.37.20;	author -;	state -;
branches;
next	1.3;

1.3
date	2013.08.07.20.10.04;	author -;	state -;
branches;
next	1.2;

1.2
date	2013.08.07.01.31.50;	author -;	state -;
branches;
next	1.1;

1.1
date	2013.08.07.01.20.49;	author -;	state -;
branches;
next	;


desc
@@


1.46
log
@-
@
text
@// $Id: xvector.h,v 1.45 2014-07-09 12:47:57-07 - - $

//
// Vector explicitly managing memory
// using allocate/deallocate/construct/destroy.
// with iterator/const_iterator.
//

#ifndef __XVECTOR_H__
#define __XVECTOR_H__

#include <initializer_list>
#include <iterator>

template <typename Type> class xvector_base;
template <typename Type> class xvector;
template <typename Type> class xvector_iterator;

// Base class guarantees all xvector ctors no uninit pointers.
// Manages allocation/deallocation of memory.
template <typename Type>
class xvector_base {
   friend class xvector<Type>;

private:
   allocator<Type> alloc;
   Type* begin {nullptr};
   Type* end {nullptr};
   Type* limit {nullptr};
   xvector_base(): begin(nullptr), end(nullptr), limit(nullptr) {}
   xvector_base (const xvector_base&) = delete;
   xvector_base& operator= (const xvector_base&) = delete;
   xvector_base (xvector_base&& that);
   xvector_base& operator= (xvector_base&&);
   ~xvector_base() { alloc.deallocate (begin, limit - begin); }
   explicit xvector_base (size_t capacity);
};


// Uses xvector_base to construct/destroy elements 
// and provide access to elements.
template <typename Type>
class xvector {

public:
   using value_type = Type;
   using reference = value_type&;
   using const_reference = const value_type&;
   using pointer = value_type*;
   using const_pointer = const value_type*;
   using difference_type = ptrdiff_t;
   using size_type = size_t;
   using iterator = xvector_iterator<value_type>;
   using const_iterator = xvector_iterator<const value_type>;

private:
   static constexpr size_type MIN_RESERVE = 4;
   xvector_base<value_type> base;
   void deallocate_this();
   void copy_from_that (const xvector&);


public:
   // Replace implicit members.
   xvector(): base() {}
   xvector (const xvector&);
   xvector (xvector&&);
   xvector& operator= (const xvector&);
   xvector& operator= (xvector&&);
   ~xvector() { resize (0); }

   // More constructors.
   explicit xvector (size_type size,
                     const value_type& val = value_type{});
   explicit xvector (initializer_list<value_type> ilist);

   // Capacity.
   size_type size() const     { return base.end - base.begin; }
   size_type capacity() const { return base.limit - base.begin; }
   bool empty() const         { return size() == 0; }
   void reserve (size_type);
   void resize (size_type, const value_type &val = value_type());

   // Modifiers: push_back, pop_back.
   void push_back (const value_type&);
   void push_back (value_type&&);
   void pop_back();

   // Iterators: begin, cbegin, end, cend.
   iterator begin()              { return iterator (base.begin); }
   const_iterator begin() const  { return iterator (base.begin); }
   const_iterator cbegin() const { return iterator (base.begin); }
   iterator end()                { return iterator (base.end); }
   const_iterator end() const    { return iterator (base.end); }
   const_iterator cend() const   { return iterator (base.end); }

   // Access: [], front, back.
   reference operator[] (size_type pos) { return base.begin[pos]; }
   const_reference operator[] (size_type pos) const
                                        { return base.begin[pos]; }
   reference front()                    { return base.begin[0]; }
   const_reference front() const        { return base.begin[0]; }
   reference back()                     { return base.end[-1]; }
   const_reference back() const         { return base.end[-1]; }
};


// Relational operators for comparing vectors lexicographically.
// Do not need to be members.
template <typename Type>
bool operator== (const xvector<Type>& lhs, const xvector<Type>& rhs);

template <typename Type>
bool operator< (const xvector<Type>& lhs, const xvector<Type>& rhs);

template <typename Type>
bool operator!= (const xvector<Type>& lhs, const xvector<Type>& rhs) {
   return not (lhs == rhs);
}

template <typename Type>
bool operator> (const xvector<Type>& lhs, const xvector<Type>& rhs) {
   return rhs < lhs;
}

template <typename Type>
bool operator<= (const xvector<Type>& lhs, const xvector<Type>& rhs) {
   return not (rhs < lhs);
}

template <typename Type>
bool operator>= (const xvector<Type>& lhs, const xvector<Type>& rhs) {
   return not (lhs < rhs);
}


// xvector<Type>::iterator
template <typename Type>
class xvector_iterator {
   friend class xvector<Type>;
   template<typename> friend class xvector_iterator;

public:
   using iterator_category = random_access_iterator_tag;
   using value_type = Type;
   using reference = value_type&;
   using pointer = value_type*;
   using const_reference = const value_type&;
   using const_pointer = const value_type*;
   using difference_type = ptrdiff_t;

private:
   pointer base {};
   xvector_iterator (pointer base): base(base) {}

public:
   xvector_iterator(): base(nullptr) {}
   // Other implicit members by default OK.

   xvector_iterator& operator++()      { ++base; return *this; }
   xvector_iterator& operator--()      { --base; return *this; }
   xvector_iterator operator++ (int);
   xvector_iterator operator-- (int);

   reference operator*()                         { return *base; }
   const_reference operator*() const             { return *base; }
   pointer operator->()                          { return base; }
   const_pointer operator->() const              { return base; }
   reference operator[] (size_t pos)             { return base[pos]; }
   const_reference operator[] (size_t pos) const { return base[pos]; }

   // Comparison and arithmetic operators.
   bool operator== (const xvector_iterator& that) const
                                 { return base == that.base; }
   bool operator<  (const xvector_iterator& that) const
                                 { return base < that.base; }
   xvector_iterator& operator+= (difference_type offset)
                                 { base += offset; return *this; }
   xvector_iterator& operator-= (difference_type offset)
                                 { base -= offset; return *this; }
   difference_type operator- (const xvector_iterator& that)
                                 { return base - that.base; }
   xvector_iterator operator+ (const difference_type offset);
   xvector_iterator operator- (const difference_type offset);

   // Implicit conversion of iterator to const_iterator.
   operator xvector_iterator<const value_type>() const
   { return xvector_iterator<const value_type> (base); }
   operator bool() { return base != nullptr; }

};


//
// XVECTOR-ITERATOR NON-MEMBER OPERATORS
//

// Can't be a member, because left opnd is not an iterator.
template <typename Type>
inline xvector_iterator<Type> operator+ (
            typename xvector_iterator<Type>::difference_type offset,
            const xvector_iterator<Type>& itor) {
   return itor + offset;
}

// Don't need to be members.  Just implement via == and <.
template <typename Type>
inline bool operator!= (const xvector_iterator<Type>& one,
                        const xvector_iterator<Type>& two) {
   return not (one == two);
}

template <typename Type>
inline bool operator> (const xvector_iterator<Type>& one,
                       const xvector_iterator<Type>& two) {
   return two < one;
}

template <typename Type>
inline bool operator<= (const xvector_iterator<Type>& one,
                        const xvector_iterator<Type>& two) {
   return not (two < one);
}

template <typename Type>
inline bool operator>= (const xvector_iterator<Type>& one,
                        const xvector_iterator<Type>& two) {
   return not (one < two);
}

#include "xvector.tcc"

#endif

@


1.45
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.44 2014-07-09 12:31:00-07 - - $
d57 1
a57 1
   static const size_type MIN_RESERVE = 4;
d189 1
@


1.44
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.43 2014-07-08 22:41:25-07 - - $
d108 30
d153 1
a153 1
   pointer base;
@


1.43
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.42 2014-05-29 19:02:56-07 - - $
d15 3
a17 3
template <typename T> class xvector_base;
template <typename T> class xvector;
template <typename T> class xvector_iterator;
d21 1
a21 1
template <typename T>
d23 1
a23 1
   friend class xvector<T>;
d26 4
a29 4
   allocator<T> alloc;
   T* begin {nullptr};
   T* end {nullptr};
   T* limit {nullptr};
d39 1
d42 1
a42 1
template <typename T>
d46 1
a46 1
   using value_type = T;
d108 1
a108 1
template <typename T>
d110 1
a110 1
   friend class xvector<T>;
d115 1
a115 1
   using value_type = T;
d168 4
a171 4
template <typename T>
inline xvector_iterator<T> operator+ (
            typename xvector_iterator<T>::difference_type offset,
            const xvector_iterator<T>& itor) {
d176 3
a178 3
template <typename T>
inline bool operator!= (const xvector_iterator<T>& one,
                        const xvector_iterator<T>& two) {
d182 3
a184 3
template <typename T>
inline bool operator> (const xvector_iterator<T>& one,
                       const xvector_iterator<T>& two) {
d188 3
a190 3
template <typename T>
inline bool operator<= (const xvector_iterator<T>& one,
                        const xvector_iterator<T>& two) {
d194 3
a196 3
template <typename T>
inline bool operator>= (const xvector_iterator<T>& one,
                        const xvector_iterator<T>& two) {
@


1.42
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.41 2014-05-05 15:56:04-07 - - $
d27 3
a29 3
   T* begin;
   T* end;
   T* limit;
d73 1
a73 1
                     const value_type& val = value_type());
@


1.41
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.40 2013-08-21 13:53:50-07 - - $
d45 9
a53 9
   typedef T value_type;
   typedef value_type& reference;
   typedef const value_type& const_reference;
   typedef value_type* pointer;
   typedef const value_type* const_pointer;
   typedef ptrdiff_t difference_type;
   typedef size_t size_type;
   typedef xvector_iterator<value_type> iterator;
   typedef xvector_iterator<const value_type> const_iterator;
d113 7
a119 7
   typedef random_access_iterator_tag iterator_category;
   typedef T value_type;
   typedef value_type& reference;
   typedef value_type* pointer;
   typedef const value_type& const_reference;
   typedef const value_type* const_pointer;
   typedef ptrdiff_t difference_type;
@


1.40
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.39 2013-08-19 19:03:59-07 - - $
d30 1
a30 1
   xvector_base(): begin(NULL), end(NULL), limit(NULL) {}
d126 1
a126 1
   xvector_iterator(): base(NULL) {}
@


1.39
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.38 2013-08-19 17:27:20-07 - - $
d84 2
a85 1
   void push_back (const value_type& value);
@


1.38
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.37 2013-08-16 18:47:27-07 - - $
d9 3
d200 2
@


1.37
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.36 2013-08-16 18:40:48-07 - - $
d137 1
a137 5
   // Implicit conversion of iterator to const_iterator.
   operator xvector_iterator<const value_type>() const
                   { return xvector_iterator<const value_type> (base); }

   // Comparison operators == and <, others defined in those terms.
d139 1
a139 1
                   { return base == that.base; }
d141 1
a141 12
                   { return base < that.base; }
   bool operator!= (const xvector_iterator& that) const
                   { return not (*this == that); }
   bool operator>  (const xvector_iterator& that) const
                   { return that < *this; }
   bool operator<= (const xvector_iterator& that) const
                   { return not (that < *this); }
   bool operator>= (const xvector_iterator& that) const
                   { return not (*this < that); }


   // Arithmetic operators.
d143 1
a143 1
                                { base += offset; return *this; }
d145 1
a145 1
                                { base -= offset; return *this; }
d147 1
a147 1
                             { return base - that.base; }
d151 4
d157 1
d170 25
@


1.36
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.35 2013-08-16 18:34:54-07 - - $
a167 1

@


1.35
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.1 2013-08-16 14:45:25-07 - - $
a136 10
   // Arithmetic operators.
   xvector_iterator& operator+= (difference_type offset)
                                { base += offset; return *this; }
   xvector_iterator& operator-= (difference_type offset)
                                { base -= offset; return *this; }
   difference_type operator- (const xvector_iterator& that)
                                { return base - that.base; }
   xvector_iterator operator+ (const difference_type offset);
   xvector_iterator operator- (const difference_type offset);

d139 1
a139 1
               { return xvector_iterator<const value_type> (base); }
d154 12
d173 1
a173 1
// Can't be a member, since left opnd is not an iterator.
@


1.34
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.33 2013-08-16 14:57:39-07 - - $
d124 1
a128 4
   reference operator*()               { return *base; }
   const_reference operator*() const   { return *base; }
   pointer operator->()                { return base; }
   const_pointer operator->() const    { return base; }
d130 8
a137 4
   bool operator== (const xvector_iterator& that) const
                                       { return base == that.base; }
   bool operator<  (const xvector_iterator& that) const
                                       { return base < that.base; }
d139 1
a139 1
                                       { base += offset; return *this; }
d141 1
a141 1
                                       { base -= offset; return *this; }
d143 3
a145 4
                                       { return base - that.base; }
   reference operator[] (size_t pos)   { return base[pos]; }
   const_reference operator[] (size_t pos) const
                                       { return base[pos]; }
d148 16
a163 3
   operator xvector_iterator<const value_type>() const {
      return xvector_iterator<const value_type> (base);
   }
d171 1
d173 4
a176 42
bool operator!= (const xvector_iterator<T>& left,
                 const xvector_iterator<T>& right) {
   return not (left == right);
}

template <typename T>
bool operator>  (const xvector_iterator<T>& left,
                 const xvector_iterator<T>& right) {
   return  (right < left);
}

template <typename T>
bool operator<= (const xvector_iterator<T>& left,
                 const xvector_iterator<T>& right) {
   return not (right < left);
}

template <typename T>
bool operator>= (const xvector_iterator<T>& left,
                 const xvector_iterator<T>& right) {
   return not (left < right);
}

template <typename T>
xvector_iterator<T> operator+ (xvector_iterator<T> itor,
                               typename xvector_iterator<T>::difference_type offset) {
   // Note: itor passed in by VALUE, not by reference.
   return itor += offset;
}

template <typename T>
xvector_iterator<T> operator+ (typename xvector_iterator<T>::difference_type offset,
                               xvector_iterator<T> itor) {
   // Note: itor passed in by VALUE, not by reference.
   return itor += offset;
}

template <typename T>
xvector_iterator<T> operator- (xvector_iterator<T> itor,
                               typename xvector_iterator<T>::difference_type offset) {
   // Note: itor passed in by VALUE, not by reference.
   return itor -= offset;
@


1.33
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.1 2013-08-16 14:45:25-07 - - $
d124 2
a125 2
   xvector_iterator& operator++()        { ++base; return *this; }
   xvector_iterator& operator--()        { --base; return *this; }
d128 5
a132 4
   reference operator*()                 { return *base; }
   const_reference operator*() const     { return *base; }
   pointer operator->()                  { return base; }
   const_pointer operator->() const      { return base; }
d134 1
a134 1
                                         { return base == that.base; }
d136 5
a140 3
                                         { return base <  that.base; }
   xvector_iterator& operator+= (long n) { base += n; return *this; }
   xvector_iterator& operator-= (long n) { base -= n; return *this; }
d142 2
a143 2
                                         { return base - that.base; }
   reference operator[] (size_t pos)     { return base[pos]; }
d145 2
a146 1
                                         { return base[pos]; }
d161 1
a161 1
   return !(left == right);
d173 1
a173 1
   return !(right < left);
d179 1
a179 1
   return !(left < right);
d183 3
a185 1
xvector_iterator<T> operator+ (xvector_iterator<T> itor, long offset) {
d190 4
a193 2
xvector_iterator<T> operator- (xvector_iterator<T> itor, long offset) {
   return itor -= offset;
d197 4
a200 2
xvector_iterator<T> operator+ (long offset, xvector_iterator<T> itor) {
   return itor += offset;
@


1.32
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.31 2013-08-16 12:48:11-07 - - $
d109 1
a109 1
   typedef bidirectional_iterator_tag iterator_category;
d124 2
a125 2
   xvector_iterator& operator++()       { ++base; return *this; }
   xvector_iterator& operator--()       { --base; return *this; }
d128 4
a131 4
   reference operator*()                { return *base; }
   const_reference operator*() const    { return *base; }
   pointer operator->()                 { return base; }
   const_pointer operator->() const     { return base; }
d133 10
a142 3
                                        { return base == that.base; }
   bool operator!= (const xvector_iterator& that) const
                                        { return not (*this == that); }
d149 44
@


1.31
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.30 2013-08-16 12:38:32-07 - - $
a10 1
#include <type_traits>
@


1.30
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.29 2013-08-15 19:05:24-07 - - $
d107 1
d120 1
a122 1
   xvector_iterator (pointer base): base(base) {}
@


1.29
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.27 2013-08-15 18:05:07-07 - - $
d11 1
d106 1
d137 3
a139 2
   operator xvector_iterator<const value_type>() const
                                        { return base; }
@


1.28
log
@-
@
text
@d86 2
a87 2
   const_iterator begin() const  { return const_iterator (base.begin); }
   const_iterator cbegin() const { return const_iterator (base.begin); }
d89 2
a90 2
   const_iterator end() const    { return const_iterator (base.end); }
   const_iterator cend() const   { return const_iterator (base.end); }
@


1.27
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.26 2013-08-15 18:00:27-07 - - $
d86 2
a87 2
   const_iterator begin() const  { return iterator (base.begin); }
   const_iterator cbegin() const { return iterator (base.begin); }
d89 2
a90 2
   const_iterator end() const    { return iterator (base.end); }
   const_iterator cend() const   { return iterator (base.end); }
@


1.26
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.24 2013-08-14 19:50:55-07 - - $
d33 1
a33 1
   xvector_base (size_t capacity);
d85 6
a90 6
   iterator begin()                     { return base.begin; }
   const_iterator begin() const         { return base.begin; }
   const_iterator cbegin() const        { return base.begin; }
   iterator end()                       { return base.end; }
   const_iterator end() const           { return base.end; }
   const_iterator cend() const          { return base.end; }
d119 1
a121 1
   xvector_iterator (pointer base): base(base) {}
@


1.25
log
@-
@
text
@d33 1
a33 1
   explicit xvector_base (size_t capacity);
d74 3
a76 3
   size_type size() const        { return base.end - base.begin; }
   size_type capacity() const    { return base.limit - base.begin; }
   bool empty() const            { return size() == 0; }
d85 6
a90 6
   iterator begin()              { return iterator (base.begin); }
   const_iterator begin() const  { return iterator (base.begin); }
   const_iterator cbegin() const { return iterator (base.begin); }
   iterator end()                { return iterator (base.end); }
   const_iterator end() const    { return iterator (base.end); }
   const_iterator cend() const   { return iterator (base.end); }
d95 5
a99 5
                                 { return base.begin[pos]; }
   reference front()             { return base.begin[0]; }
   const_reference front() const { return base.begin[0]; }
   reference back()              { return base.end[-1]; }
   const_reference back() const  { return base.end[-1]; }
a104 1
   friend class xvector<T>;
a116 1
   explicit xvector_iterator (pointer base): base(base) {}
d121 1
d136 1
a136 1
                                        { return *this; }
@


1.24
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.23 2013-08-14 19:49:48-07 - - $
d33 1
a33 1
   xvector_base (size_t capacity);
d74 3
a76 3
   size_type size() const     { return base.end - base.begin; }
   size_type capacity() const { return base.limit - base.begin; }
   bool empty() const         { return size() == 0; }
d85 6
a90 6
   iterator begin()                     { return base.begin; }
   const_iterator begin() const         { return base.begin; }
   const_iterator cbegin() const        { return base.begin; }
   iterator end()                       { return base.end; }
   const_iterator end() const           { return base.end; }
   const_iterator cend() const          { return base.end; }
d95 5
a99 5
                                        { return base.begin[pos]; }
   reference front()                    { return base.begin[0]; }
   const_reference front() const        { return base.begin[0]; }
   reference back()                     { return base.end[-1]; }
   const_reference back() const         { return base.end[-1]; }
d105 1
d118 1
a122 1
   xvector_iterator (pointer base): base(base) {}
d137 1
a137 1
                                        { return base; }
@


1.23
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.22 2013-08-14 19:47:19-07 - - $
d21 1
a35 1

d40 1
d51 1
d58 1
d102 1
d105 1
d114 1
d117 1
@


1.22
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.21 2013-08-14 19:15:37-07 - - $
d35 1
@


1.21
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.20 2013-08-14 18:33:10-07 - - $
a11 1
// Base class guarantees all xvector ctors no uninit pointers.
d14 1
a14 1
template <typename T, typename U> class xvector_iterator;
d16 2
d22 1
a22 1
   static allocator<T> alloc;
d26 1
a26 1
   xvector_base();
d31 1
a31 1
   ~xvector_base();
d35 2
a39 1
//   template <typename T, typename U> class xvector_iterator;
d47 2
a48 2
   typedef xvector_iterator<T, value_type> iterator;
   typedef xvector_iterator<T, const value_type> const_iterator;
d57 1
a57 1
   xvector();
d62 1
a62 1
   ~xvector();
d70 3
a72 3
   size_type size() const;
   size_type capacity() const;
   bool empty() const;
d81 6
a86 6
   iterator begin();
   const_iterator begin() const;
   const_iterator cbegin() const;
   iterator end();
   const_iterator end() const;
   const_iterator cend() const;
d89 7
a95 6
   reference operator[] (size_type pos);
   const_reference operator[] (size_type pos) const;
   reference front();
   const_reference front() const;
   reference back();
   const_reference back() const;
d98 1
a98 1
template <typename T, typename U>
a99 1
   friend class xvector<T>;
d102 1
a102 1
   typedef U value_type;
d109 1
a109 2
   pointer current;
   xvector_iterator (pointer);
d111 1
a111 1
   xvector_iterator();
d113 3
a115 2
   xvector_iterator& operator++();
   xvector_iterator& operator--();
d118 8
a125 6
   reference operator*();
   const_reference operator*() const;
   pointer operator->();
   const_pointer operator->() const;
   bool operator== (const xvector_iterator&) const;
   bool operator!= (const xvector_iterator& that) const;
d127 2
a128 1
   operator xvector_iterator<T, const value_type>() const;
@


1.20
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.18 2013-08-14 14:52:06-07 - - $
d13 3
a15 3
template <typename T>
class xvector;

d37 1
a37 2
   template <typename U>
   class iterator_base;
d45 2
a46 2
   typedef iterator_base<value_type> iterator;
   typedef iterator_base<const value_type> const_iterator;
d95 2
a96 3
template <typename T>
template <typename U>
class xvector<T>::iterator_base {
d108 1
a108 1
   iterator_base (pointer);
d110 1
a110 1
   iterator_base();
d112 4
a115 4
   iterator_base& operator++();
   iterator_base& operator--();
   iterator_base operator++ (int);
   iterator_base operator-- (int);
d120 2
a121 2
   bool operator== (const iterator_base&) const;
   bool operator!= (const iterator_base& that) const;
d123 1
a123 1
   operator iterator_base<const value_type>() const;
@


1.19
log
@-
@
text
@a53 1

a95 1

@


1.18
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.17 2013-08-14 14:39:32-07 - - $
a15 2
template <typename T>
class xvector_iterator;
d37 2
d46 2
a47 2
   typedef xvector_iterator<value_type> iterator;
   typedef xvector_iterator<const value_type> const_iterator;
d57 1
a57 1
   xvector() {}
d99 3
a101 1
class xvector_iterator {
d104 2
a105 1
   typedef T value_type;
d107 1
a107 1
   typedef value_type& reference;
a108 1
   typedef const value_type& const_reference;
d111 2
a112 1
   pointer current_ptr;
d114 1
a114 1
   xvector_iterator(): current_ptr(NULL) {};
d116 4
a119 5
   xvector_iterator (pointer ptr): current_ptr(ptr) {}
   xvector_iterator& operator++();
   xvector_iterator& operator--();
   xvector_iterator operator++ (int);
   xvector_iterator operator-- (int);
d124 2
a125 2
   bool operator== (const xvector_iterator&) const;
   bool operator!= (const xvector_iterator& that) const;
d127 1
a127 1
   operator xvector_iterator<const value_type>() const;
@


1.17
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.16 2013-08-14 14:16:03-07 - - $
d17 1
a17 1
class iterator_base;
d46 2
a47 2
   typedef iterator_base<value_type> iterator;
   typedef iterator_base<const value_type> const_iterator;
d99 1
a99 1
class iterator_base {
d111 1
a111 1
   iterator_base(): current_ptr(NULL) {};
d113 5
a117 5
   iterator_base (pointer ptr): current_ptr(ptr) {}
   iterator_base& operator++();
   iterator_base& operator--();
   iterator_base operator++ (int);
   iterator_base operator-- (int);
d122 2
a123 2
   bool operator== (const iterator_base&) const;
   bool operator!= (const iterator_base& that) const;
d125 1
a125 1
   operator iterator_base<const value_type>() const;
@


1.16
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.15 2013-08-13 19:07:31-07 - - $
d57 1
a57 1
   xvector();
a99 1
   friend class xvector<T>;
d109 1
a109 1
   pointer base_;
d111 1
a111 1
   iterator_base(): base_(NULL) {};
d113 11
a123 21
   iterator_base (pointer ptr): base_(ptr) {}
   iterator_base& operator++() { ++base_; return *this; }
   iterator_base& operator--() { --base_; return *this; }
   iterator_base operator++ (int) {
      iterator_base<value_type> result (*this);
      ++base_;
      return result;
   }
   iterator_base operator-- (int) {
      iterator_base<value_type> result (*this);
      --base_;
      return result;
   }
   reference operator*() { return *base_; }
   const_reference operator*() const { return *base_; }
   pointer operator->() { return base_; }
   const_pointer operator->() const { return base_; }
   bool operator== (const iterator_base& that) const
         { return base_ == that.base_; }
   bool operator!= (const iterator_base& that) const
         { return not (*this == that); }
d125 1
a125 2
   operator iterator_base<const value_type>() const
         { return iterator_base<const value_type> (base_); }
@


1.15
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.14 2013-08-13 18:42:53-07 - - $
a10 4
#include <memory>
#include <utility>

using namespace std;
d17 3
d22 12
a33 12
   private:
      static allocator<T> alloc;
      T* begin;
      T* end;
      T* limit;
      xvector_base();
      xvector_base (const xvector_base&) = delete;
      xvector_base& operator= (const xvector_base&) = delete;
      xvector_base (xvector_base&& that);
      xvector_base& operator= (xvector_base&&);
      ~xvector_base();
      xvector_base (size_t capacity);
d38 15
a52 17
   public:
      typedef T value_type;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef ptrdiff_t difference_type;
      typedef size_t size_type;
      template <typename VT>
      class iterator_base;
      typedef iterator_base<value_type> iterator;
      typedef iterator_base<const value_type> const_iterator;
   private:
      static const size_type MIN_RESERVE = 4;
      xvector_base<value_type> base;
      void deallocate_this();
      void copy_from_that (const xvector&);
d55 40
a94 40
   public:
      // Replace implicit members.
      xvector() {} // Depends on xvector_base.
      xvector (const xvector&);
      xvector (xvector&&);
      xvector& operator= (const xvector&);
      xvector& operator= (xvector&&);
      ~xvector();

      // More constructors.
      explicit xvector (size_type size,
                        const value_type& val = value_type());
      explicit xvector (initializer_list<value_type> ilist);

      // Capacity.
      size_type size() const;
      size_type capacity() const;
      bool empty() const;
      void reserve (size_type);
      void resize (size_type, const value_type &val = value_type());

      // Modifiers: push_back, pop_back.
      void push_back (const value_type& value);
      void pop_back();

      // Iterators: begin, cbegin, end, cend.
      iterator begin();
      const_iterator begin() const;
      const_iterator cbegin() const;
      iterator end();
      const_iterator end() const;
      const_iterator cend() const;

      // Access: [], front, back.
      reference operator[] (size_type pos);
      const_reference operator[] (size_type pos) const;
      reference front();
      const_reference front() const;
      reference back();
      const_reference back() const;
d99 1
a99 3
template <typename VT>
class xvector<T>::iterator_base:
   public std::iterator<bidirectional_iterator_tag,VT> {
d101 37
a137 29
   private:
      pointer base_;
      iterator_base (pointer ptr): base_(ptr) {}
   public:
      iterator_base(): base_(NULL) {};
      // Other implicit members by default OK.
      iterator_base& operator++() { ++base_; return *this; }
      iterator_base& operator--() { --base_; return *this; }
      iterator_base operator++ (int) {
         xvector<T>::iterator_base<VT> result (*this);
         ++base_;
         return result;
      }
      iterator_base operator-- (int) {
         xvector<T>::iterator_base<VT> result (*this);
         --base_;
         return result;
      }
      reference operator*() { return *base_; }
      const_reference operator*() const { return *base_; }
      pointer operator->() { return base_; }
      const_pointer operator->() const { return base_; }
      bool operator== (const iterator_base& that) const
            { return base_ == that.base_; }
      bool operator!= (const iterator_base& that) const
            { return not (*this == that); }
      // Implicit conversion of iterator to const_iterator.
      operator iterator_base<const T>() const
            { return iterator_base<const T> (base_); }
@


1.14
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.13 2013-08-13 18:37:27-07 - - $
d60 1
a60 1
      xvector() {}
a71 10
      // Iterators: begin, cbegin, end, cend.
      iterator begin() { return iterator (base.begin); }
      const_iterator begin() const
            { return const_iterator (base.begin); }
      const_iterator cbegin() const
            { return const_iterator (base.begin); }
      iterator end() { return iterator (base.end); }
      const_iterator end() const { return const_iterator (base.end); }
      const_iterator cend() const { return const_iterator (base.end); }

d73 3
a75 3
      size_type size() const { return base.end - base.begin; }
      size_type capacity() const { return base.limit - base.begin; }
      bool empty() const { return size() == 0; }
a78 9
      // Access: [], front, back.
      reference operator[] (size_type pos) { return base.begin[pos]; }
      const_reference operator[] (size_type pos) const
            { return base.begin[pos]; }
      reference front() { return base.begin[0]; }
      const_reference front() const { return base.begin[0]; }
      reference back() { return base.end[-1]; }
      const_reference back() const { return base.end[-1]; }

d82 16
@


1.13
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.12 2013-08-13 17:27:16-07 - - $
d47 1
a47 1
      template <typename TI>
d105 1
a105 1
template <typename TI>
d107 1
a107 1
   public std::iterator<bidirectional_iterator_tag,TI> {
d118 1
a118 1
         xvector<T>::iterator_base<TI> result (*this);
d123 1
a123 1
         xvector<T>::iterator_base<TI> result (*this);
@


1.12
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.10 2013-08-13 14:53:57-07 - - $
d10 1
d47 4
a50 5
      template <typename TI, typename Pointer = TI*,
                typename Reference = TI&>
      class base_iterator;
      typedef base_iterator<value_type> iterator;
      typedef base_iterator<const value_type> const_iterator;
d105 3
a107 2
template <typename TI, typename Pointer, typename Reference>
class xvector<T>::base_iterator {
a108 6
   public:
      typedef TI value_type;
      typedef ptrdiff_t difference_type;
      typedef Pointer pointer;
      typedef Reference reference;
      typedef bidirectional_iterator_tag iterator_category;
d111 1
a111 1
      base_iterator (pointer ptr): base_(ptr) {}
d113 1
a113 1
      base_iterator(): base_(NULL) {};
d115 4
a118 4
      base_iterator& operator++() { ++base_; return *this; }
      base_iterator& operator--() { --base_; return *this; }
      base_iterator operator++ (int) {
         xvector<T>::base_iterator<TI> result (*this);
d122 2
a123 2
      base_iterator operator-- (int) {
         xvector<T>::base_iterator<TI> result (*this);
d128 1
a128 1
      const reference operator*() const { return *base_; }
d130 2
a131 2
      const pointer operator->() const { return base_; }
      bool operator== (const base_iterator& that) const
d133 1
a133 1
      bool operator!= (const base_iterator& that) const
d136 2
a137 2
      operator base_iterator<const T>() const
            { return base_iterator<const T> (base_); }
@


1.11
log
@-
@
text
@d10 3
d27 1
a27 1
      xvector_base(): begin(NULL), end(NULL), limit(NULL) {}
d32 1
a32 1
      ~xvector_base() { alloc.deallocate (begin, limit - begin); }
d54 2
d62 1
a62 1
      xvector (xvector&& that): base (std::move (that.base)) {}
d65 1
a65 1
      ~xvector() { resize (0); }
d68 1
a68 1
      explicit xvector (size_type fill_size,
@


1.10
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.9 2013-08-12 18:55:17-07 - - $
a9 3
#include <memory>
#include <utility>

a50 2
      void deallocate_this();
      void copy_from_that (const xvector&);
d57 1
a57 1
      xvector (xvector&&);
d60 1
a60 1
      ~xvector();
d63 1
a63 1
      explicit xvector (size_type size,
@


1.9
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.8 2013-08-12 14:58:55-07 - - $
d11 1
d17 3
d21 13
a33 7
   protected:
      T* begin_;
      T* end_;
      T* limit_;
      xvector_base(): begin_(NULL), end_(NULL), limit_(NULL) {}
      void set_pointers (T* begin, T* end, T* limit)
            { begin_ = begin; end_ = end; limit_ = limit; }
d37 1
a37 5
class xvector: private xvector_base<T> {
      using xvector_base<T>::begin_;
      using xvector_base<T>::end_;
      using xvector_base<T>::limit_;
      using xvector_base<T>::set_pointers;
d53 1
a53 1
      static allocator<value_type> alloc;
a55 1
      void move_from_that (xvector&&);
d73 8
a80 6
      iterator begin() { return iterator (begin_); }
      const_iterator begin() const { return const_iterator (begin_); }
      const_iterator cbegin() const { return const_iterator (begin_); }
      iterator end() { return iterator (end_); }
      const_iterator end() const { return const_iterator (end_); }
      const_iterator cend() const { return const_iterator (end_); }
d83 2
a84 2
      size_type size() const { return end_ - begin_; }
      size_type capacity() const { return limit_ - begin_; }
d90 1
a90 1
      reference operator[] (size_type pos) { return begin_[pos]; }
d92 5
a96 5
            { return begin_[pos]; }
      reference front() { return begin_[0]; }
      const_reference front() const { return begin_[0]; }
      reference back() { return end_[-1]; }
      const_reference back() const { return end_[-1]; }
@


1.8
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.7 2013-08-12 14:50:01-07 - - $
d48 2
a49 1
      void deallocate();
a50 1
      void copy_from_that (const xvector&);
@


1.7
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.6 2013-08-08 12:03:25-07 - - $
a47 1
      void destroy_this();
@


1.6
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.5 2013-08-07 13:45:39-07 - - $
d22 2
a23 1
      void set_pointers (T* begin, T* end, T* limit);
d85 2
a86 3
      const_reference operator[] (size_type pos) const {
         return begin_[pos];
      }
d130 4
a133 6
      bool operator== (const base_iterator& that) const {
         return base_ == that.base_;
      }
      bool operator!= (const base_iterator& that) const {
         return not (*this == that);
      }
d135 2
a136 3
      operator base_iterator<const T>() const {
         return base_iterator<const T> (base_);
      }
@


1.5
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.4 2013-08-07 13:37:20-07 - - $
d104 1
a106 1
      typedef ptrdiff_t difference_type;
@


1.4
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.2 2013-08-06 18:31:50-07 - - $
d94 1
a94 1
      void pop_back() { alloc.destroy (--end_); }
@


1.3
log
@-
@
text
@d106 1
a106 1
      typedef xvector<T>::difference_type difference_type;
@


1.2
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.1 2013-08-06 18:20:49-07 - - $
d48 1
@


1.1
log
@-
@
text
@d1 1
a1 1
// $Id: xvector.h,v 1.21 2013-08-06 15:35:59-07 - - $
d63 1
a63 1
                         const value_type& val = value_type());
d79 1
@
