head	1.76;
access;
symbols;
locks;
comment	@.\" @;


1.76
date	2015.04.14.19.25.47;	author -;	state -;
branches;
next	1.75;

1.75
date	2015.01.16.03.42.57;	author -;	state -;
branches;
next	1.74;

1.74
date	2014.06.26.23.58.23;	author -;	state -;
branches;
next	1.73;

1.73
date	2014.06.26.23.56.01;	author -;	state -;
branches;
next	1.72;

1.72
date	2014.06.26.23.54.46;	author -;	state -;
branches;
next	1.71;

1.71
date	2014.05.30.02.12.35;	author -;	state -;
branches;
next	1.70;

1.70
date	2014.04.23.22.44.53;	author -;	state -;
branches;
next	1.69;

1.69
date	2014.04.18.03.27.36;	author -;	state -;
branches;
next	1.68;

1.68
date	2014.04.16.02.14.50;	author -;	state -;
branches;
next	1.67;

1.67
date	2014.04.10.21.05.15;	author -;	state -;
branches;
next	1.66;

1.66
date	2014.04.10.21.01.05;	author -;	state -;
branches;
next	1.65;

1.65
date	2014.04.10.20.42.41;	author -;	state -;
branches;
next	1.64;

1.64
date	2014.04.10.20.39.12;	author -;	state -;
branches;
next	1.63;

1.63
date	2014.04.10.19.47.20;	author -;	state -;
branches;
next	1.62;

1.62
date	2014.04.10.19.46.35;	author -;	state -;
branches;
next	1.61;

1.61
date	2014.04.10.19.44.35;	author -;	state -;
branches;
next	1.60;

1.60
date	2014.04.10.19.44.21;	author -;	state -;
branches;
next	1.59;

1.59
date	2014.04.10.19.43.15;	author -;	state -;
branches;
next	1.58;

1.58
date	2014.04.10.19.41.40;	author -;	state -;
branches;
next	1.57;

1.57
date	2014.04.10.00.23.59;	author -;	state -;
branches;
next	1.56;

1.56
date	2014.04.10.00.23.11;	author -;	state -;
branches;
next	1.55;

1.55
date	2014.04.10.00.22.41;	author -;	state -;
branches;
next	1.54;

1.54
date	2014.04.10.00.21.59;	author -;	state -;
branches;
next	1.53;

1.53
date	2014.04.09.23.40.01;	author -;	state -;
branches;
next	1.52;

1.52
date	2014.04.09.00.45.16;	author -;	state -;
branches;
next	1.51;

1.51
date	2013.07.22.20.25.55;	author -;	state -;
branches;
next	1.50;

1.50
date	2013.07.15.19.45.41;	author -;	state -;
branches;
next	1.49;

1.49
date	2013.07.10.03.14.06;	author -;	state -;
branches;
next	1.48;

1.48
date	2013.07.09.21.46.42;	author -;	state -;
branches;
next	1.47;

1.47
date	2013.06.27.21.11.58;	author -;	state -;
branches;
next	1.46;

1.46
date	2013.06.27.20.45.02;	author -;	state -;
branches;
next	1.45;

1.45
date	2013.06.27.20.37.59;	author -;	state -;
branches;
next	1.44;

1.44
date	2013.06.27.20.26.39;	author -;	state -;
branches;
next	1.43;

1.43
date	2013.06.27.20.25.47;	author -;	state -;
branches;
next	1.42;

1.42
date	2013.06.27.20.25.20;	author -;	state -;
branches;
next	1.41;

1.41
date	2013.06.27.19.59.00;	author -;	state -;
branches;
next	1.40;

1.40
date	2013.06.27.19.58.18;	author -;	state -;
branches;
next	1.39;

1.39
date	2013.06.27.19.52.38;	author -;	state -;
branches;
next	1.38;

1.38
date	2013.06.27.19.51.51;	author -;	state -;
branches;
next	1.37;

1.37
date	2013.06.26.03.19.06;	author -;	state -;
branches;
next	1.36;

1.36
date	2013.06.26.03.18.41;	author -;	state -;
branches;
next	1.35;

1.35
date	2013.06.26.03.17.53;	author -;	state -;
branches;
next	1.34;

1.34
date	2013.06.26.03.15.55;	author -;	state -;
branches;
next	1.33;

1.33
date	2013.06.26.03.11.10;	author -;	state -;
branches;
next	1.32;

1.32
date	2013.06.26.03.09.17;	author -;	state -;
branches;
next	1.31;

1.31
date	2013.06.26.03.07.53;	author -;	state -;
branches;
next	1.30;

1.30
date	2013.06.26.03.07.03;	author -;	state -;
branches;
next	1.29;

1.29
date	2013.06.26.03.06.35;	author -;	state -;
branches;
next	1.28;

1.28
date	2013.06.26.03.04.04;	author -;	state -;
branches;
next	1.27;

1.27
date	2013.06.26.03.02.08;	author -;	state -;
branches;
next	1.26;

1.26
date	2013.06.26.02.59.46;	author -;	state -;
branches;
next	1.25;

1.25
date	2013.06.26.02.58.44;	author -;	state -;
branches;
next	1.24;

1.24
date	2013.06.26.02.56.34;	author -;	state -;
branches;
next	1.23;

1.23
date	2013.06.26.02.44.48;	author -;	state -;
branches;
next	1.22;

1.22
date	2013.06.26.02.41.23;	author -;	state -;
branches;
next	1.21;

1.21
date	2013.06.26.00.28.48;	author -;	state -;
branches;
next	1.20;

1.20
date	2013.01.25.20.04.06;	author -;	state -;
branches;
next	1.19;

1.19
date	2013.01.24.03.04.20;	author -;	state -;
branches;
next	1.18;

1.18
date	2013.01.24.02.59.24;	author -;	state -;
branches;
next	1.17;

1.17
date	2013.01.24.02.58.34;	author -;	state -;
branches;
next	1.16;

1.16
date	2013.01.24.02.58.22;	author -;	state -;
branches;
next	1.15;

1.15
date	2013.01.24.02.58.06;	author -;	state -;
branches;
next	1.14;

1.14
date	2013.01.24.02.54.49;	author -;	state -;
branches;
next	1.13;

1.13
date	2013.01.24.02.54.08;	author -;	state -;
branches;
next	1.12;

1.12
date	2013.01.24.02.53.42;	author -;	state -;
branches;
next	1.11;

1.11
date	2013.01.24.02.49.48;	author -;	state -;
branches;
next	1.10;

1.10
date	2013.01.24.02.49.05;	author -;	state -;
branches;
next	1.9;

1.9
date	2013.01.24.02.47.26;	author -;	state -;
branches;
next	1.8;

1.8
date	2013.01.24.02.47.12;	author -;	state -;
branches;
next	1.7;

1.7
date	2013.01.24.02.46.48;	author -;	state -;
branches;
next	1.6;

1.6
date	2013.01.24.02.45.05;	author -;	state -;
branches;
next	1.5;

1.5
date	2013.01.24.01.59.49;	author -;	state -;
branches;
next	1.4;

1.4
date	2013.01.24.01.59.01;	author -;	state -;
branches;
next	1.3;

1.3
date	2013.01.24.01.58.30;	author -;	state -;
branches;
next	1.2;

1.2
date	2013.01.24.01.41.36;	author -;	state -;
branches;
next	1.1;

1.1
date	2013.01.24.00.58.37;	author -;	state -;
branches;
next	;


desc
@@


1.76
log
@-
@
text
@.so Tmac.mm-etc
.if t .Newcentury-fonts
.INITR* \n[.F]
.SIZE 12 14
.TITLE CMPS-109 Spring\~2015 Program\~2 "Overloading and operators"
.RCS "$Id: asg2-dc-bigint.mm,v 1.75 2015-01-15 19:42:57-08 - - $"
.PWD
.URL
.EQ
delim $$
define uvec  |{ bold u }|
define vvec  |{ bold v }|
define pvec  |{ bold p }|
tdefine rem     |{type binary "\f[CR]%\f[P]"}|
.EN
.H 1 "Overview"
This assignment will involve overloading basic integer operators
to perform arbitrary precision integer arithmetic in the style of
.V= dc (1).
Your class
.V= bigint
will intermix arbitrarily with simple integer arithmetic.
.P
To begin read the 
.V= man (1)
page for the command
.V= dc (1)\(::
.VCODE* 1 "man -s 1 dc" 
A copy of that page is also in this directory.
Your program will use the standard 
.V= dc
as a reference  implemention and must produce exactly
the same output for the commands you have to implement\(::
.VCODE* 1 "+\0 -\0 *\0 /\0 %\0 \[ha]\0 c\0 d\0 f\0 p\0 q\0"
.P
Also look in the subdirectory
.V= misc/
for some examples and in
.V= output/
for the result of running the test data using
.V= dc .
.H 1 "Implementation strategy"
As before, you have been given starter code.
.ALX a ()
.LI
.V= Makefile ,
.V= trace ,
and
.V= util
are similar to the previous program.
If you find you need a function which does not properly belong to
a given module, you may add it to
.V= util .
.LI
The module 
.V= scanner
reads in tokens, namely a
.V= NUMBER ,
an
.V= OPERATOR ,
or
.V= SCANEOF .
Each token returns a
.V= token_t ,
which indicates what kind of token it is
(the
.V= "terminal_symbol symbol" ),
and the
.V= "string lexinfo"
associated
with the token.
Only in the case of a number is there more than one character.
Note that on input, an underscore
.=V ( _ )
indicates a negative number.
The minus sign
.=V ( - )
is reserved only as a binary operator.
The scanner also has defined a couple of
.V= operator<<
for printing out scanner results in
.V= TRACE
mode.
.LI
The main program
.V= main.cpp ,
has been implemented for you.
For the six binary arithmetic functions,
the right operand is popped from the stack,
then the left operand,
then the result is pushed onto the stack.
.LI
The module
.V= iterstack
can not just be the STL
.V= stack ,
since we want to iterate from top to bottom,
and the STL
.V= stack
does not have an iterator.
A stack depends on the operations
.V= back() ,
.V= push_back() ,
and
.V= pop_back()
in the underlying container.
We could use a
.V= vector ,
a
.V= deque ,
or just a 
.V= list ,
as long as the requisite operations are available.
.LE
.H 1 "Class \f[CB]bigint\f[P]"
Then we come to the most complex part of the assignment,
namely the class
.V= bigint .
Operators in this class are heavily overloaded.
.ALX a ()
.LI
most of the functions take a arguments of type
.V= "const bigint &" ,
i.e.,
a constant reference,
for the sake of efficiency.
But they have to return the result by value.
.LI
We want all of the operators to be able to take either a
.V= bigint
or a
.V= long
as either the left or right operand.
Because of this we make the arithmetic operators
.V= friend s
instead of members.
That will cause automatic conversion from a
.V= long
to a
.V= bigint
via the constructor that accepts a
.V= long
argument.
.LI
The
.V= operator<<
can't be a member since its left operand is an
.V= ostream ,
so we make it a
.V= friend ,
so that it can see the innards of a
.V= bigint .
Note now
.V= dc
prints really big numbers.
.LI
The
.V= pow
function exponentiates in
.if n { O ( log sub 2 n ) }
.if t $ O ( log sub 2 n ) $
and need not be changed.
It is not a member of
.V= bigint ,
but it behaves as a member,
since it uses only other functions.
.LI
The relational operators
.V= ==
and
.V= <
are coded individually as member functions.
The others, 
.V= != ,
.V= <= ,
.V= > ,
and
.V= >=
are defined in terms of the essential two.
.LI
The
.V= /
and
.V= %
functions call
.V= divide ,
which is private.
One can not produce a quotient without a remainder, 
and vice versa,
so it returns a pair which is both the quotient and remainder,
and the operator just discards the one that is not needed.
.LI
The given implementation works for small integers,
but overflows for large integers.
.H 1 "Representation of a bigint"
Now we turn to the representation of a 
.V= bigint ,
which will be represented by a boolean flag and a vector of integers.
.ALX a ()
.LI
Replace the declaration
.VCODE* 1 "long long_value;"
with
.VCODE* 1 "using digit_t = unsigned char;"
.VCODE* 1 "using bigvalue_t = vector<digit_t>;"
.VCODE* 1 "bool negative;"
.VCODE* 1 "bigvalue_t big_value;"
in 
.V= bigint.h .
.LI
In storing the long integer it is recommended that each digit in
the range 0 to 9 is kept in an element, 
although true
.V= dc (1)
stores two digits per byte.
But we are not concerned here with extreme efficiency.
Since the arithmetic operators add and subtract work from least
significant digit to most significant digit,
store the elements of the vector in the same order.
That means, for example, that the number $4629$ would be stored in
a vector $v$ as\(::
$v sub 3 = 4 $,
$v sub 2 = 6 $,
$v sub 1 = 2 $,
$v sub 0 = 9 $.
In other words,
if a digit's value is
$d times 10 sup k$,
then $v sub k = d$.
.LI
In order for the comparisons to work correctly,
always store numbers in a canonical form\(::
After computing a value from any one of the six arithmetic operators,
always trim the vector by removing all high-order zeros.
While 
.V= size()\~>\~0
and
.V= back()
returns zero,
.V= pop_back()
the high order digit.
Zero should be represented as a vector of zero length
and a positive sign.
.LI
The representation of a number will be as follows\(::
.V= negative
is a flag which indicates the sign of the number\(;;
.V= big_value 
contains the digits of the number.
.LI
Then use 
.V= grep
or your editor's search function to find all of the occurrences of
.V= long_value .
Each of these occurrences needs to be replaced.
Change all of the constructors so that instead of initializing
.V= long_value ,
they initialize the replacement value.
.LI
The scanner will produce numbers as
.V= string s,
so scan each string from the end of the string,
using a 
.V= const_reverse_iterator
(or other means)
from the end of the string (least significant digit)
to the beginning of the string (most significant digit)
using
.V= push_back
to append them to the vector.
.LE
.H 1 "Implementation of Operators"
.ALX a ()
.LI
Add two new private functions
.V= do_bigadd
and
.V= do_bigsub \(::
.VTCODE* 1 "bigvalue_t do_bigadd (const bigvalue_t&, const bigvalue_t&);
.VTCODE* 1 "bigvalue_t do_bigsub (const bigvalue_t&, const bigvalue_t&);
.LI
Change
.V= operator+
so that it compares the two numbers it gets.
If the signs are the same,
it calls
.V= do_bigadd
to add the vectors and keeps the sign as the result.
If the signs are different,
call
.V= do_bigless
to determine which one is smaller,
and then call 
.V= do_bigsub
to subtract the larger minus the smaller.
Note that this is a different comparison function
which compares absolute values only.
Avoid duplicate code wherever possible.
.LI
The
.V= operator-
should perform similarly.
If the signs are different, it uses
.V= do_bigadd ,
but if the same, it uses
.V= do_bigsub .
.LI
To implement
.V= do_bigadd ,
create a new 
.V= bigvalue_t
and proceed from the low order end to the high order end,
adding digits pairwise.
If any sum is >=\~10,
take the remainder and add the carry to the next digit.
Use
.V= push_back
to append the new digits to the
.V= bigvalue_t .
When you run out of digits in the shorter number,
continue, matching the longer vector with zeros,
until it is done.
Make sure the sign of 0 is positive.
.LI
To implement
.V= do_bigsub ,
also create a new empty vector, starting from the low order end
and continuing until the high end.
In this case, if the left number is smaller than the right number,
the subtraction will be less than zero.
In that case, add 10, and set the borrow to the next number to \-1.
You are, of course, guaranteed here, that the left number is
at least as large as the right number.
After the algorithm is done,
.V= pop_back
all high order zeros from the vector before returning it.
Make sure the sign of 0 is positive.
.LI
You will need to implement
.V= do_bigless ,
which will compare the absolute values of the vectors
to determine which is smaller\(::
.VTCODE* 1 "bool do_bigless (const bigvalue_t&, const bigvalue_t&);
.LI
To implement
.V= operator== ,
check to see if the signs are the same and the lengths of
the vectors are the same.
If not, return false.
Otherwise run down both vectors and return false as soon a difference
is found.
Otherwise return true.
.LI
To implement
.V= operator< ,
remember that a negative number is less than a positive number.
If the signs are the same,
for positive numbers, the shorter one is less,
and for negative nubmers, the longer one is less.
If the signs and lengths are the same,
run down the parallel vectors from the high order end to the low
order end.
When a difference is found, return true or false, as appropriate.
If no difference is found, return false.
.LI
Implement function
.V= do_bigmul ,
which is called from
.V= operator* .
.V= Operator*
uses the rule of signs to determine the sign of the result,
and calls
.V= do_bigmul
to compute the product vector.
.LI
Multiplication in
.V= do_bigmul
proceeds by allocating a new vector
whose size is 
equal to the sum of the sizes of the other two operands.
If $uvec$ is a vector of size $m$
and $vvec$ is a vector of size $n$,
then in $ O ( m n ) $ speed,
perform an outer loop over one argument and an inner loop over
the other argument, adding the new partial products to the product 
$pvec$ as you would by hand.
The algorithm can be described mathematically as follows\(::
.DS I
.br 
$ pvec <- PHI $
$ for ~ i elem [ 0 , m ) ~ : $ 
$ TAB c <- 0 $
$ TAB for ~ j elem [ 0 , n ) ~ : $ 
$ TAB TAB d <- pvec sub { i + j } + uvec sub i vvec sub j + c $ 
$ TAB TAB pvec sub { i + j } <- d rem 10 $
$ TAB TAB c <- left floor d div 10 right floor $ 
$ TAB pvec sub { i + n } <- c $
.br 
.DE 
Note that the interval $ [ a , b ) $ refers to the set
$ roman "{" x | a <= x < b roman "}" $,
i.e., to a half-open interval including $a$ but excluding $b$.
In the same way,
a pair of iterators in C++ bound an interval.
.LI
Long division is complicated if done correctly.
See a paper by P. Brinch Hansen,
``Multiple-length division revisited\(::
A tour of the minefield'',
.I "Software \[em] Practice and Experience 24",
(June 1994), 579\[en]601.
Algorithms 1 to 12 are on pages 13\[en]23,
Note that in Pascal,
array bounds are part of the type,
which is not true for
.V= vector s
in C++.
.VTCODE* 0 multiple-length-division.pdf
.VTCODE* 0 http://brinch-hansen.net/papers/1994b.pdf
.VTCODE* 0 \
http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5815
.LI
The function
.V= divide
as implemented uses the ancient Egyptian division algorithm,
which is slower than Hansen's Pascal program,
but is easier to understand.
Replace the
.V= long
values in it by 
.V= vector<digit_t> .
The logic is shown also in
.=V [ misc/divisioncpp.cpp ].
The algorithm is rather slow,
but the big-$O$ analysis is reasonable.
.LI
Modify
.V= operator<< ,
first just to print out the number all in one line.
You will need this to debug your program.
When you are finished,
make it print numbers in the same way as
.V= dc (1)
does.
.LI
The
.V= pow
function is not a member and uses other operations to raise
a number to a power.
If the exponent does not fit into a single
.V= long
print an error message,
otherwise do the computation.
.LE
.H 1 "Memory leak"
Make sure that you test your program completely so that it does not
crash on a Segmentation Fault or any other unexpected error.
Since you are not using pointers,
and all values are inline,
there should be no memory leak.
Use
.V= valgrind
to check for and eliminate uninitialized variables and memory leak.
.H 1 "What to submit"
Submit source files and only source files\(::
.V= Makefile ,
.V= README ,
and all of the header and implementation files necessary to build
the target executable.
If
.V= gmake
does not build
.V= ydc 
your program can not be tested and you lose 1/2 of the points for
the assignment.
Use
.V= checksource
on  your code.
.P
If you are doing pair programming,
follow the additional instructions in
.V= Syllabus/pair-programming/ 
and also submit
.V= PARTNER .
.FINISH
@


1.75
log
@-
@
text
@d5 2
a6 2
.TITLE CMPS-109 Winter\~2015 Program\~2 "Overloading and operators"
.RCS "$Id: asg2-dc-bigint.mm,v 1.74 2014-06-26 16:58:23-07 - - $"
@


1.74
log
@-
@
text
@d5 2
a6 2
.TITLE CMPS-109 Spring\~2014 Program\~2 "Overloading and operators"
.RCS "$Id: asg2-dc-bigint.mm,v 1.73 2014-06-26 16:56:01-07 - - $"
@


1.73
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.72 2014-06-26 16:54:46-07 - - $"
a19 5
You will also perform explicit memory management using
.V= new
and
.V= delete ,
and eliminate memory leak.
d458 3
a460 5
Then implement the destructor
.V= ~bigint
so that there is no memory leak.
But if you don't have time to do this, remember that
memory leak is not as bad as a core dump.
@


1.72
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.71 2014-05-29 19:12:35-07 - - $"
d241 2
a242 2
.V= size()
is > 0 and
@


1.71
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.70 2014-04-23 15:44:53-07 - - $"
d127 1
a127 1
Note that most of the functions take a right argument of type
d129 3
a131 1
that is a constant reference, for the sake of efficiency.
d139 4
a142 17
.LI
When the left operand is an
.V= long ,
we make them non-member operators,
with two arguments, the left being an 
.V= long
and the right a
.V= bigint .
Note that the implementation of these functions,
.V= + ,
.V= - ,
.V= * ,
.V= / ,
.V= % ,
.V= == ,
.V= <  ,
are all identical, namely that they cast the
d146 1
a146 8
and call the other operator.
This is unnecessary for
.V= != ,
.V= <= ,
.V= > ,
.V= >= ,
since they are inline functions,
and given a
d148 1
a148 4
on either side,
the non-explicit constructor
.V= "bigint (const long)"
will cause an implicit conversion.
@


1.70
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.69 2014-04-17 20:27:36-07 - - $"
d230 2
a231 2
.VCODE* 1 "typedef unsigned char digit_t;"
.VCODE* 1 "typedef vector<digit_t> bigvalue_t;"
@


1.69
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.68 2014-04-15 19:14:50-07 - - $"
d305 2
a306 2
.VTCODE* 1 "bigvalue_t do_bigadd (const bigvalue_t&, const bigfalue_t&);
.VTCODE* 1 "bigvalue_t do_bigsub (const bigvalue_t&, const bigfalue_t&);
d369 1
a369 1
.VTCODE* 1 "bool do_bigless (const bigvalue_t&, const bigfalue_t&);
@


1.68
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.67 2014-04-10 14:05:15-07 - - $"
d305 2
a306 2
.VTCODE* 1 bigvalue_t do_bigadd (const bigvalue_t&, const bigfalue_t&);
.VTCODE* 1 bigvalue_t do_bigsub (const bigvalue_t&, const bigfalue_t&);
d369 1
a369 1
.VTCODE* 1 bool do_bigless (const bigvalue_t&, const bigfalue_t&);
@


1.67
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.66 2014-04-10 14:01:05-07 - - $"
d304 3
a306 1
.V= do_bigsub .
d317 2
a318 2
.V= abs_compare
to determine which one is larger,
d368 2
a369 1
to determine which is larger.
@


1.66
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.65 2014-04-10 13:42:41-07 - - $"
a8 1
.GETST* MATH_FIGURE Figure_MATH_FIGURE
a427 18
.LI 
.LI
The algorithm in Figure \*[Figure_MATH_FIGURE] (c)
is not acceptable, because it has $ O ( m 10 sup n ) $
(exponential) running time.
The others use $ O ( m n ) $ running time.
.LI
The function
.V= divide
is implemented for you as a general algorithm.
Replace the
.V= long
values in it by 
.V= vector<digit_t> .
The logic is shown also in
.=V [ misc/divisioncpp.cpp ].
The algorithm is rather slow,
but the big-$O$ analysis is reasonable.
d446 14
@


1.65
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.64 2014-04-10 13:39:12-07 - - $"
d15 1
a15 1
tdefine rem     |{type binary "\f[R]%\f[P]"}|
d415 1
a415 1
$ for ~ i elem left [ 0 , m ) ~ : $ 
d417 1
a417 1
$ TAB for ~ j elem left [ 0 , n ) ~ : $ 
@


1.64
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.63 2014-04-10 12:47:20-07 - - $"
d12 4
a15 4
define uvec  |{ u vec }|
define vvec  |{ v vec }|
define pvec  |{ p vec }|
tdefine rem     |{type binary "\f[R]rem\f[P]"}|
a413 2
.S +1 +1
.br 
d415 1
a415 1
$ for ~ i elem left [ 0 ... m - 1 right ] ~ : $ 
d417 1
a417 1
$ TAB for ~ j elem left [ 0 ... n - 1 right ] ~ : $ 
a422 2
.S -1 -1
.br 
d427 2
a428 1
Iterators in C++ generally work this way to bound an interval.
@


1.63
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.62 2014-04-10 12:46:35-07 - - $"
a298 44
.DF
.SP
.TS
expand tab(|); |c |c |c |.
_
Algorithm (a)|Algorithm (b)|Algorithm (c)
_
.SP
T{
.nf
$pvec <- 0 vec $
$for ~ i elem [ 0 , m ) ~ : $
$TAB c <- 0 $
$TAB for ~ j elem [ 0 , n ) ~ : $
$TAB TAB d <- pvec sub { i + j } + uvec sub i vvec sub j + c $
$TAB TAB pvec sub { i + j } <- d rem 10 $
$TAB TAB c <- left floor d div 10 right floor $
$TAB pvec sub { i + n } <- c $
T}|T{
.nf
$pvec <- 0 vec $
$while ~ vvec != hat 0 vec ~ : $
$TAB if ~ odd vvec ~ : $
$TAB TAB pvec <- pvec + hat uvec $
$TAB TAB vvec <- vvec - hat 1 vec $
$TAB else ~ : $
$TAB TAB uvec <- uvec mul hat 2 vec $
$TAB TAB vvec <- vvec div hat 2 vec $
T}|T{
.nf
// This algorithm is not
// acceptable because of
// exponential running time.
$pvec <- 0 vec $
$while ~ vvec != hat 0 vec ~ : $
$TAB pvec <- pvec + hat uvec $
$TAB vvec <- vvec - hat 1 vec $
T}
.SP
_
.TE
.FG "Two vector multiplication algorithms" "" 0 MATH_FIGURE
.SP
.DE
d411 17
a427 2
The algorithm can be described mathematically as shown in Figure
\*[Figure_MATH_FIGURE] (a).
a432 7
An alternative method of computing the product runs a little more
slowly because of the extra function calls,
as shown in Figure \*[Figure_MATH_FIGURE] (b).
The symbols $+ hat$, $- hat$, $times hat$, $div hat$, etc.,
represent vector rather than scalar operations.
A static function must be written for each of these if this 
implementation method is chosen. 
@


1.62
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.61 2014-04-10 12:44:35-07 - - $"
d299 1
a299 1
.DF CB
d302 1
a302 1
tab(|); |c |c |c |.
@


1.61
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.60 2014-04-10 12:44:21-07 - - $"
d299 1
a299 1
.DF RB
@


1.60
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.59 2014-04-10 12:43:15-07 - - $"
d551 1
a551 1
.V= /afs/cats.ucsc.edu/courses/cmps012b-wm/Syllabus/pair-programming/ 
@


1.59
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.58 2014-04-10 12:41:40-07 - - $"
d499 1
a499 1
.VTCODE* 0 misc/multiple-length-division.pdf
@


1.58
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.57 2014-04-09 17:23:59-07 - - $"
d217 2
a218 8
so there is one function.
An
.V= enum
constant, either
.V= QUOTIENT
or
.V= REMAINDER
tells the function which to return.
@


1.57
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.56 2014-04-09 17:23:11-07 - - $"
a206 4
Instead of defining them here we could have used
.V= "#include <utility>"
and
.V= "using namespace std::rel_ops;"
@


1.56
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.55 2014-04-09 17:22:41-07 - - $"
d309 1
a309 1
.DF CB
@


1.55
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.54 2014-04-09 17:21:59-07 - - $"
d309 1
a309 1
.DF
@


1.54
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.53 2014-04-09 16:40:01-07 - - $"
d312 1
a312 1
expand tab(|); |ce |ce |ce |.
@


1.53
log
@-
@
text
@d5 2
a6 2
.TITLE CMPS-109 Spring\~2014 Program\~2 "Overloading and memory mgmt"
.RCS "$Id: asg2-dc-bigint.mm,v 1.52 2014-04-08 17:45:16-07 - - $"
@


1.52
log
@-
@
text
@d6 1
a6 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.51 2013-07-22 13:25:55-07 - - $"
d503 6
@


1.51
log
@-
@
text
@d4 3
a6 2
.TITLE CMPS-109 Summer\~2013 Program\~2 "Overloading and memory mgmt"
.RCS "$Id: asg2-dc-bigint.mm,v 1.50 2013-07-15 12:45:41-07 - - $"
@


1.50
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.49 2013-07-09 20:14:06-07 - - $"
d454 1
a454 1
.V= do_bigmum
@


1.49
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.48 2013-07-09 14:46:42-07 - - $"
d27 1
a27 3
will intermix arbitrarily with simple
.V= int
arithmetic.
d134 2
a135 2
or an
.V= int
d139 1
a139 1
.V= int ,
d142 1
a142 1
.V= int
@


1.48
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.47 2013-06-27 14:11:58-07 - - $"
d419 5
d429 1
a429 1
Then run down both vectors and return false as soon a difference
d517 9
@


1.47
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.46 2013-06-27 13:45:02-07 - - $"
d245 1
a245 1
.VCODE* 1 "bigvalue_t *big_value;"
@


1.46
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.45 2013-06-27 13:37:59-07 - - $"
d42 7
d93 1
a93 1
.V= main.cc ,
@


1.45
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.44 2013-06-27 13:26:39-07 - - $"
d492 4
a495 1
.=V [ misc/multiple-length-division.pdf ].
@


1.44
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.43 2013-06-27 13:25:47-07 - - $"
d474 20
@


1.43
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.42 2013-06-27 13:25:20-07 - - $"
d319 1
a319 1
$TAB TAB c <- d div 10 $
@


1.42
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.41 2013-06-27 12:59:00-07 - - $"
d14 1
a14 1
tdefine rem     |{type binary "\f[R]R\f[P]"}|
@


1.41
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.40 2013-06-27 12:58:18-07 - - $"
d14 1
a14 1
tdefine rem     |{type binary "\f[R]%\f[P]"}|
@


1.40
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.39 2013-06-27 12:52:38-07 - - $"
d14 1
a14 1
tdefine rem     |{type binary "\f[CR]%\f[P]"}|
@


1.39
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.38 2013-06-27 12:51:51-07 - - $"
d14 1
@


1.38
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.37 2013-06-25 20:19:06-07 - - $"
a13 2
define rem   |{ type binary "%" }|
define ...   |{ type binary { roman "..." } }|
@


1.37
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.36 2013-06-25 20:18:41-07 - - $"
d439 1
a439 1
checks uses the rule of signs to determine the sign of the result,
@


1.36
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.35 2013-06-25 20:17:53-07 - - $"
d345 1
a346 1
.FG "Two vector multiplication algorithms" "" 0 MATH_FIGURE
@


1.35
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.34 2013-06-25 20:15:55-07 - - $"
d304 44
a483 44
.DS
.SP
.TS
expand tab(|); |ce |ce |ce |.
_
Algorithm (a)|Algorithm (b)|Algorithm (c)
_
.SP
T{
.nf
$pvec <- 0 vec $
$for ~ i elem [ 0 , m ) ~ : $
$TAB c <- 0 $
$TAB for ~ j elem [ 0 , n ) ~ : $
$TAB TAB d <- pvec sub { i + j } + uvec sub i vvec sub j + c $
$TAB TAB pvec sub { i + j } <- d rem 10 $
$TAB TAB c <- d div 10 $
$TAB pvec sub { i + n } <- c $
T}|T{
.nf
$pvec <- 0 vec $
$while ~ vvec != hat 0 vec ~ : $
$TAB if ~ odd vvec ~ : $
$TAB TAB pvec <- pvec + hat uvec $
$TAB TAB vvec <- vvec - hat 1 vec $
$TAB else ~ : $
$TAB TAB uvec <- uvec mul hat 2 vec $
$TAB TAB vvec <- vvec div hat 2 vec $
T}|T{
.nf
// This algorithm is not
// acceptable because of
// exponential running time.
$pvec <- 0 vec $
$while ~ vvec != hat 0 vec ~ : $
$TAB pvec <- pvec + hat uvec $
$TAB vvec <- vvec - hat 1 vec $
T}
.SP
_
.TE
.SP
.FG "Two vector multiplication algorithms" "" 0 MATH_FIGURE
.DE
@


1.34
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.33 2013-06-25 20:11:10-07 - - $"
d303 3
@


1.33
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.32 2013-06-25 20:09:17-07 - - $"
d263 13
a275 5
Then use 
.V= grep
or your editor's search function to find all of the occurrences of
.V= small_value .
Each of these occurrences needs to be replaced.
d283 5
d289 1
a289 1
.V= small_value ,
@


1.32
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.31 2013-06-25 20:07:53-07 - - $"
d237 1
a237 1
.VCODE* 1 "typedef vector <digit_t> bigvalue_t;"
d252 1
a252 1
That means, for example, that the number $4622$ would be stored in
d257 1
a257 1
$v sub 0 = 2 $.
@


1.31
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.30 2013-06-25 20:07:03-07 - - $"
d163 1
a163 1
the non-explicit
d234 1
a234 1
.VCODE* 1 "int small_value;"
a396 1
.LI
@


1.30
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.29 2013-06-25 20:06:35-07 - - $"
d479 1
a479 1
to check for memory leak.
@


1.29
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.28 2013-06-25 20:04:04-07 - - $"
d399 1
a399 1
$ left { x | a <= x < right } $,
@


1.28
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.27 2013-06-25 20:02:08-07 - - $"
d399 1
a399 1
$ "{" x | a <= x < "}" $,
@


1.27
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.26 2013-06-25 19:59:46-07 - - $"
d397 5
@


1.26
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.25 2013-06-25 19:58:44-07 - - $"
d431 1
a431 1
$for ~ i elem 0 ... m - 1 ~ : $
d433 1
a433 1
$TAB for ~ j elem 0 ... n - 1 ~ : $
@


1.25
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.24 2013-06-25 19:56:34-07 - - $"
d408 1
a408 1
running time.
d433 1
a433 1
$TAB for ~ j elem 0 ... n - 1 ) ~ : $
@


1.24
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.23 2013-06-25 19:44:48-07 - - $"
d407 3
a409 1
is not acceptable.
@


1.23
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.22 2013-06-25 19:41:23-07 - - $"
d8 1
d11 5
d354 54
a407 17
.V= compare ,
return a value that is $< 0$, $= 0$, or $> 0$,
to show the relationship.
First check the signs.
If different,
you immediately know which inequality to return.
If the same, and for positive numbers,
the longer vector (with more digits) is greater than the shorter one.
If they are the same length,
start comparing digits from the (high-order) end
of the vector to the (low-order) front for a difference,
For negative numbers,
the smaller number is greater.
which tells you the inequality.
Otherwise return equal.
This assumes that vectors are stored in a canonical manner
without high-order zeros.
d418 44
@


1.22
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.21 2013-06-25 17:28:48-07 - - $"
d196 4
d206 1
a206 1
.V= divrem ,
d209 9
a217 1
and vice versa.
a220 10
.LI
The operator
.V= *
and
.V= divrem
use the Ancient Egyptian multiplication and division algorithms,
which only need the ability to add and subtract,
and use a stack.
Presumably Pharaoh's engineers used this algorithm.
Fill in the missing code.
@


1.21
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.20 2013-01-25 12:04:06-08 - - $"
a141 1
.V= != ,
a142 3
.V= <= ,
.V= > ,
.V= >= ,
d144 1
a144 1
.V= int
d148 12
a404 16
.H 1 Reference
.DS
.ds-nt Kheops Kh\['e]eops \[*X]\[*e']\[*o]\[*q]
.TS
tab(|); l r.
T{
.VTCODE 0 http://en.wikipedia.org/wiki/Great_Pyramid_of_Giza
.VTCODE 0 http://en.wikipedia.org/wiki/Khufu \0\0\0 (\*[Kheops])
.VTCODE 0 http://en.wikipedia.org/wiki/Egyptian_numerals
.VTCODE 0 \
http://www.mathnstuff.com/math/spoken/here/2class/60/egyptm.htm
T}|T{
.if dPSPIC .PSPIC cartouches/khufu.ps 1.25i
T}
.TE
.DE
@


1.20
log
@-
@
text
@d4 2
a5 2
.TITLE CMPS-109 Winter\~2013 Program\~2 "Overloading and memory mgmt"
.RCS "$Id: asg2-dc-bigint.mm,v 1.19 2013-01-23 19:04:20-08 - - $"
d137 1
a137 1
.V= = ,
d171 1
a171 1
While it is a member of
d173 2
a174 1
it behaves like a non-member, using only other functions.
d176 12
a187 3
The relational operators all trivially call a
.V= compare
function, which is private, and needs to be rewritten.
@


1.19
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.18 2013-01-23 18:59:24-08 - - $"
d399 1
a399 1
.if dPSPIC .PSPIC khufu/khufuhieroglyphs.ps 1.25i
@


1.18
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.17 2013-01-23 18:58:34-08 - - $"
d399 1
a399 1
.if dPSPIC .PSPIC khufu/khufuhieroglyphs.ps 1.5i
@


1.17
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.16 2013-01-23 18:58:22-08 - - $"
d394 1
a394 1
.VTCODE 0 http://en.wikipedia.org/wiki/Khufu \0(\*[Kheops])
d396 2
a397 1
.VTCODE 0 http://www.mathnstuff.com/math/spoken/here/2class/60/egyptm.htm
@


1.16
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.15 2013-01-23 18:58:06-08 - - $"
d398 1
a398 1
.if dPSPIC .PSPIC khufu/khufuhieroglyphs.ps 1i
@


1.15
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.14 2013-01-23 18:54:49-08 - - $"
d398 1
a398 1
.if dPSPIC .PSPIC khufu/khufuhieroglyphs.ps 2i
@


1.14
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.13 2013-01-23 18:54:08-08 - - $"
d398 1
a398 1
.if dPSPIC .PSPIC khufu/khufuhieroglyphs.ps 1i
@


1.13
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.12 2013-01-23 18:53:42-08 - - $"
d389 1
d391 1
a391 1
tab(|); lw(5i) r.
a392 1
.fi
d394 1
a394 3
.VTCODE 0 http://en.wikipedia.org/wiki/Khufu
.ds-nt Kheops Kh\['e]eops \[*X]\[*e']\[*o]\[*q]
\0(\*[Kheops])
@


1.12
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.11 2013-01-23 18:49:48-08 - - $"
d390 1
a390 1
tab(|); lw(4i) r.
d400 1
a400 1
.if dPSPIC .PSPIC khufu/khufuhieroglyphs.ps .75i
@


1.11
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.10 2013-01-23 18:49:05-08 - - $"
a200 15
.H 1 Reference
.DS
.TS
tab(|); lw(4i) r.
T{
.fi
.VTCODE 0 http://en.wikipedia.org/wiki/Great_Pyramid_of_Giza
.VTCODE 0 http://en.wikipedia.org/wiki/Khufu
.ds-nt Kheops Kh\['e]eops \[*X]\[*e']\[*o]\[*q]
\0(\*[Kheops])
T}|T{
.if dPSPIC .PSPIC khufu/khufuhieroglyphs.ps .75i
T}
.TE
.DE
d387 17
@


1.10
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.9 2013-01-23 18:47:26-08 - - $"
d204 1
a204 1
tab(|); l r.
@


1.9
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.8 2013-01-23 18:47:12-08 - - $"
d201 1
d206 1
d212 1
a212 1
.if dPSPIC .PSPIC khufu/khufuhieroglyphs.ps 1i
@


1.8
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.7 2013-01-23 18:46:48-08 - - $"
d209 1
a209 1
.T}|T{
@


1.7
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.6 2013-01-23 18:45:05-08 - - $"
d212 2
@


1.6
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.5 2013-01-23 17:59:49-08 - - $"
d201 4
d209 1
d211 1
@


1.5
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.4 2013-01-23 17:59:01-08 - - $"
d205 1
@


1.4
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.3 2013-01-23 17:58:30-08 - - $"
d203 1
a203 1
.ds-nt Kheops Kh\['e]eops \[*C]\[*e']\[*o]\[*q]
@


1.3
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.2 2013-01-23 17:41:36-08 - - $"
d204 1
a204 1
\0(\*[Xeops])
@


1.2
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.1 2013-01-23 16:58:37-08 - - $"
d203 2
a204 1
( Xeops )
@


1.1
log
@-
@
text
@d5 1
a5 1
.RCS "$Id: asg2-dc-bigint.mm,v 1.14 2013-01-23 13:32:12-08 - - $"
d189 3
d201 3
a203 4
.LI
Finally,
the given implementation works for small integers,
but overflows for large integers.
@
